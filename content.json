{"meta":{"title":"lyjの博客","subtitle":"纸上得来终觉浅，绝知此事要躬行","description":"坚持就是胜利","author":"刘亚娟","url":"http://www/lyj1215.com"},"pages":[{"title":"categories","date":"2017-09-08T07:22:17.000Z","updated":"2017-09-08T07:22:17.000Z","comments":true,"path":"categories/index.html","permalink":"http://www/lyj1215.com/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2017-09-08T06:55:40.000Z","updated":"2017-09-08T08:17:44.000Z","comments":true,"path":"about/index.html","permalink":"http://www/lyj1215.com/about/index.html","excerpt":"","text":"Email:liuyajuan15@qq.com Github:https://github.com/juaner 娟娟串珠 纸上得来终觉浅，绝知此事要躬行"},{"title":"友情链接","date":"2017-09-08T07:28:00.000Z","updated":"2017-09-08T07:40:58.000Z","comments":true,"path":"links/index.html","permalink":"http://www/lyj1215.com/links/index.html","excerpt":"","text":"晓铮大神: http://www.lxzfranky.com/ 广训大神: https://zhgxun.github.io"}],"posts":[{"title":"正则表达式测试题","slug":"regex2","date":"2017-09-13T02:28:41.000Z","updated":"2017-09-15T10:11:48.000Z","comments":true,"path":"2017/09/13/regex2/","link":"","permalink":"http://www/lyj1215.com/2017/09/13/regex2/","excerpt":"","text":"正则掌握程度测试题,以下测试题来自于 https://www.zybuluo.com/Zjmainstay/note/709093， 答案是我自己的分析，欢迎各位进行批评与指导,部分习题答案后续不上 一. 分组提取/非捕获组 分组，是正则里一个非常重要的概念，我们需要针对某个区域提取数据，往往需要依赖分组。而分组，其实就是正则里()括住的部分。 分组提取 123456需求：在分组1中匹配meta中author属性的值源串： &lt;meta author=\"Zjmainstay\" /&gt; another author=\"Zjmainstay too\"预期：分组1得到Zjmainstay正则：'/&lt;meta[^&gt;]author=\"(.*?)\".*?\\/&gt;/' 非捕获组 针对上面的分组，有时候，我们并不需要捕获某个分组的内容，我们可以使用非捕获组(?:表达式)，从而不捕获表达式部分内容到分组中。 12345678源串：aababcabcd预期：匹配得到 ab 和 abcd，不包含分组1正则： '/^(?:\\w\\w)+$/m' 二. 单字符或 或条件是正则使用过程中常用的概念，比如，密码由字母或数字组成，这里就用到了或条件，而且，由于字母或数字都是单个字符，因此，可以使用[a-z0-9]这样的单字符或语法实现。 常犯错误：匹配a或b写成[a|b]，此表达式实际上表示a或b或|，在[]内部的|表示其本身，注意区分(a|b)表示a或b的写法。 123456789101112需求：匹配由 A/S/D/F 4个字母(区分大小写)组成的长度为3字符串源串：ABCASDADSASFBBCA|SA|DASDF预期：以[]元字符获得3个字母的或集，匹配 ASD/ADS/ASF 3组数据正则：'/\\b[ASDF]&#123;3&#125;\\b/m' 三. 多字符或 相对单字符或条件，多字符或也是很常见的，比如，我们需要匹配http或ftp两个协议头的url，就需要^(http|ftp)://.+$这样的语法来实现。 123456789101112需求：匹配每行数据中以.jpg/.jpeg/.png/.gif结尾的图片名称（含后缀）源串：image.jpgimage.jpegimage.pngimage.gifnot_image.txtnot_image.docnot_image.xlsnot_image.ppt预期：匹配 image.jpg/image.jpeg/image.png/image.gif 4个结果正则：'/.*?\\.(jpg|jpeg|png|gif)/m' 四. 分组引用 前面介绍了分组，那某个分组在我们匹配过程中重复出现，又该如何处理？分组引用恰恰解决这个问题。比如，匹配出现重复单词的一行数据，我们可以这么写（多行模式）：/^.?(\\b\\S+\\b).?\\1.*$/m，\\1表示引用前面分组1中匹配到的内容，也就是重复的单词内容。 12345678需求：匹配连续相同3次的数字源串：111121112222预期：匹配 111/222 两组数据正则：'/(\\d)\\1\\1/m' 五. 匹配换行数据 “我的正则本来好好的，突然不行了！”这个是很多正则新人遇到的问题，而这个问题，很多时候，就是因为原来正则中的.不能匹配新数据里的换行导致的。这时候，只需要把.改成[\\s\\S]这样的表达式就可以了。这个表达式表示空格或非空格，也就是任意字符啦。 12345678需求：分别使用单行模式和普通模式匹配id=\"author\"的div中数据，div标签不在同一行源串：&lt;div id=\"author\"&gt;Zjmainstay&lt;/div&gt;预期：Zjmainstay正则1：'@&lt;div[^&gt;]id=\"author\"&gt;(.*?)&lt;/div&gt;@ms'正则2： 六. 存在（或） 匹配多种或条件的数据，没有特殊限制 1234567891011121314需求：匹配每行中包含“作者”或者“读者”的数据源串：本文的作者是Zjmainstay本文有很多读者读者可以是任何一个地方的人这里的任何一个地方说明读者也能在国外什么乱七八糟的推理你不匹配我，凭什么要我推荐你的博客 www.zjmainstay.cn预期：匹配本文的作者是Zjmainstay本文有很多读者读者可以是任何一个地方的人这里的任何一个地方说明读者也能在国外正则：$re = '/^.*?(作者|读者).*?$/m' 匹配多种或条件的数据，有特殊限制（不使用环视） 123456789需求：匹配每行中“读者”在开头或结尾的数据源串：本文作者是Zjmainstay，有很多读者读者可以是任何一个地方的人这里的任何一个地方说明读者也能在国外预期：匹配本文作者是Zjmainstay，有很多读者读者可以是任何一个地方的人正则： 匹配多种或条件的数据，有特殊限制（使用环视） 123456789需求：匹配每行中“读者”在开头或结尾的数据源串：本文作者是Zjmainstay，有很多读者读者可以是任何一个地方的人这里的任何一个地方说明读者也能在国外预期：匹配本文作者是Zjmainstay，有很多读者读者可以是任何一个地方的人正则： 七. 存在（与）校验密码必须包含字母、数字和特殊字符，6-16位12345678910111213141516171819202122需求：校验密码必须包含字母、数字和特殊字符，6-16位，假定特殊字符为 -_= 三个字符源串：12345123456123456123456123412345612345612345a1234a12345-1234-12345a-123a-1234a-1234a-1234a-12a-1234a-1234a-1234aaaaaaaaaaa-_=-_-_=-_=预期：匹配a-1234a-1234a-1234a-12正则： 八. 特殊限制（环视否定） 使用\\d{1,3}匹配1-999的数据，不能以0开头 123456789101112131415需求：使用\\d&#123;1,3&#125;匹配每行中1-999的数据，不能以0开头源串：110100999100001001预期：匹配110100999正则：'/(?!0)(?&lt;!\\d)\\d&#123;1,3&#125;\\b/' 匹配除了span标签外的所有标签 1234567891011需求：匹配除了&lt;span&gt;内容&lt;/span&gt;标签外的所有&lt;tagName&gt;内容&lt;/tagName&gt;格式标签源串：&lt;div&gt;匹配我&lt;/div&gt;&lt;span&gt;不匹配我&lt;/span&gt;&lt;p&gt;匹配我&lt;/p&gt;&lt;i&gt;匹配我&lt;/i&gt;预期：匹配&lt;div&gt;匹配我&lt;/div&gt;&lt;p&gt;匹配我&lt;/p&gt;&lt;i&gt;匹配我&lt;/i&gt;正则： 九. 替换分组使用 给源串每个链接加上http://www.zjmainstay.cn前缀 123456789101112131415需求：给源串每个链接加上http://www.zjmainstay.cn前缀源串：&lt;a id=\"link-1\" href=\"/regexp-one\"&gt;正则文章合集（All In One)&lt;/a&gt;&lt;a id=\"link-2\" href=\"/my-regexp\"&gt;正则入门教程&lt;/a&gt;&lt;a id=\"link-3\" href=\"/deep-regexp\"&gt;正则高级教程&lt;/a&gt;&lt;a id=\"link-4\" href=\"/regexp-lookaround\"&gt;正则环视详解&lt;/a&gt;&lt;a id=\"link-5\" href=\"/php-curl\"&gt;PHP cURL应用&lt;/a&gt;预期：替换得到&lt;a id=\"link-1\" href=\"http://www.zjmainstay.cn/regexp-one\"&gt;正则文章合集（All In One)&lt;/a&gt;&lt;a id=\"link-2\" href=\"http://www.zjmainstay.cn/my-regexp\"&gt;正则入门教程&lt;/a&gt;&lt;a id=\"link-3\" href=\"http://www.zjmainstay.cn/deep-regexp\"&gt;正则高级教程&lt;/a&gt;&lt;a id=\"link-4\" href=\"http://www.zjmainstay.cn/regexp-lookaround\"&gt;正则环视详解&lt;/a&gt;&lt;a id=\"link-5\" href=\"http://www.zjmainstay.cn/php-curl\"&gt;PHP cURL应用&lt;/a&gt;查找：替换： 将每行数据格式化为一条SQL语句 1234567891011需求：将每行特定格式数据格式化为SQL语句源串：1 2017-04-11 Zjmainstay2 2017-04-12 Nobody3 2017-04-13 Somebody预期：替换得到INSERT INTO table_log(`id`, `created_at`, `author`) values('1', '2017-04-11', 'Zjmainstay');INSERT INTO table_log(`id`, `created_at`, `author`) values('2', '2017-04-12', 'Nobody');INSERT INTO table_log(`id`, `created_at`, `author`) values('3', '2017-04-13', 'Somebody');查找：替换： 十. 分组可选 分组可选 123456789101112需求：判断如果单词以A开头，匹配Apple；如果单词以B开头，匹配Banana；否则匹配Empty源串：AngleAppleBananaBestEmpty预期：匹配AppleBananaEmpty正则： 分组可选与分组引用 123456789需求：匹配html标签的属性值，属性值可以由双引号、单引号、无单双引号定界源串：&lt;div id=\"I'm Zjmainstay\" class=\"name\" data-year=2017 age='27'&gt;预期：分组匹配I'm Zjmainstayauthor201727正则： 十一. 单字符拆分（数字）匹配0.00-100.00的数值，可以有0-2位小数1234567891011121314151617181920212223242526需求：匹配0.00-100.00的数值，可以有0-2位小数，不能以小数点结尾，不能以2个以上的0开头思路：(100|10-99|0-9) + 0-2小数位 + 排除小数点结尾、2个以上0开头的情况源串：010.00.009.0018.0027.036.0045.0054.0063.0072.0081.0090.0099.99100.000.001100.01100.001101预期：匹配0.00~100.00正则： 十二. 贪婪模式 匹配链接中的文件名 12345678需求：利用贪婪模式，分组1得到每行链接中的文件名源串：http://localhost.com/a/b/c/d/file1.txthttps://localhost.com/a/b/file2long.jpg预期：分组0匹配行数据，分组1匹配文件名file1.txtfile2long.jpg正则： 限定字符贪婪优化匹配性能 12345需求：匹配div id=\"author\"的标签内容源串：&lt;div id=\"author\" class=\"author-text something-useless\"&gt;Zjmainstay&lt;/div&gt;预期：利用贪婪模式去掉div中的噪点（无关数据），分组1匹配到Zjmainstay正则： 十三. 非贪婪模式 贪婪模式，正则会优先尽可能少地匹配能匹配到的内容。当剩余正则匹配剩余部分字符（源串）但无法满足匹配时，非贪婪部分继续匹配更多内容，尝试满足剩余部分字符的匹配。 匹配p标签内容123456需求：匹配p标签内容源串：&lt;p&gt;内容1&lt;/p&gt;&lt;p&gt;内容2&lt;/p&gt;预期：在分组1中匹配到内容1和内容2正则： 十四. 占用模式(PCRE) 贪婪模式后再加一个+量词，如.++，效果是贪婪而且不回溯。 暂时没有想到应用场景。 十五. |字符分界（|的作用域） |作为或条件分隔符，它的分隔区间常常存在误用。在使用|字符的过程中，我们常常需要结合()来对它进行限定。如，^([0-9]+|[a-z]+)$表示纯数字或纯字母，如果没有()，那它又是另一种意思了。^[0-9]+|[a-z]+$等价于^[0-9]+或[a-z]+$，因此，它表示数字开头或者字母结尾，跟我们的需求有了很大的差别。 |字符分界12345678需求：在分组1中匹配css或script的链接源串：&lt;script src=\"main.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"main.css\"&gt;预期：main.min.jsmain.css正则： 十六. 元字符转义 元字符，指正则中有特殊意义的字符，如.表示匹配除了换行符以外的任意字符，这个.就是元字符。在正则书写过程中，如果我们真的要匹配这个.，就需要对它进行转义，而不是让它使用正则的含义，比如，匹配域名里的.，我们就要写成/zjmainstay.cn/这样的正则。 元字符转义123456789101112需求：表达式格式固定，提取其中的数值源串：(20+170)-5*1/5=?预期：A:20B:170C:5D:1E:5F:?正则：替换： 十七. 分隔符绕过（PCRE） 有时候，如果该语言支持多种分隔符，在写正则的过程中通常会通过规避分隔符的方式，减少对分隔符的转义，让正则看起来更清晰，写起来更舒服，当然，js中是不支持的。 分隔符绕过123456需求：在不对/转义的情况下匹配p标签内容源串：&lt;p&gt;内容1&lt;/p&gt;&lt;p&gt;内容2&lt;/p&gt;预期：在分组1中匹配到内容1和内容2正则： 十八. 匹配溢出排除 匹配溢出，这不是一个术语名词，是我自己的叫法，主要指正则匹配内容超出了我们预期，导致匹配得到非预期的结果。 div标签匹配溢出 1234567需求：匹配内容为数字的div源串：&lt;div class=\"aaa bbb\"&gt;ABC&lt;/div&gt;&lt;div class=\"bbb ccc\"&gt;123&lt;/div&gt;预期：&lt;div&gt;123&lt;/div&gt;错误正则：/&lt;div.*?&gt;\\d+&lt;\\/div&gt;/正则： 多字符排除 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556需求：匹配不包含某个单词或词语的内容源串：http://www.zjmainstay.cnhttp://www.baidu.comhttp://www.qq.com预期：http://www.zjmainstay.cnhttp://www.qq.com正则：需求：匹配不包含某个单词或词语的内容源串：A(\"Excalibur\", \"誓约胜利之剑\", LONG_SWORD, (SPFX_NOGEN | SPFX_RESTR | SPFX_SEEK | SPFX_DEFN | SPFX_INTEL | SPFX_SEARCH), 0, 0, PHYS(5, 10), DRLI(0, 0), NO_CARY, 0, A_LAWFUL, PM_KNIGHT, NON_PM, 4000L, NO_COLOR);/* * Stormbringer only has a 2 because it can drain a level, * providing 8 more. */A(\"Stormbringer\", \"兴风者\", RUNESWORD, (SPFX_RESTR | SPFX_ATTK | SPFX_DEFN | SPFX_INTEL | SPFX_DRLI), 0, 0, DRLI(5, 2), DRLI(0, 0), NO_CARY, 0, A_CHAOTIC, NON_PM, NON_PM, 8000L, NO_COLOR);/* * Mjollnir will return to the hand of the wielder when thrown * if the wielder is a Valkyrie wearing Gauntlets of Power. */A(\"Mjollnir\", \"雷神之锤\", WAR_HAMMER, /* Mjo:llnir */ (SPFX_RESTR | SPFX_ATTK), 0, 0, ELEC(5, 24), NO_DFNS, NO_CARY, 0, A_NEUTRAL, PM_VALKYRIE, NON_PM, 4000L, NO_COLOR);A(\"Cleaver\", \"撕裂者\", BATTLE_AXE, SPFX_RESTR, 0, 0, PHYS(3, 6), NO_DFNS, NO_CARY, 0, A_NEUTRAL, PM_BARBARIAN, NON_PM, 1500L, NO_COLOR);/* * Grimtooth glows in warning when elves are present, but its * damage bonus applies to all targets rather than just elves * (handled as special case in spec_dbon()). */A(\"Grimtooth\", \"邪兽之牙\", ORCISH_DAGGER, (SPFX_RESTR | SPFX_WARN | SPFX_DFLAG2), 0, M2_ELF, PHYS(2, 6), NO_DFNS, NO_CARY, 0, A_CHAOTIC, NON_PM, PM_ORC, 300L, CLR_RED);/* * Orcrist and Sting have same alignment as elves. * * The combination of SPFX_WARN+SPFX_DFLAG2+M2_value will trigger * EWarn_of_mon for all monsters that have the M2_value flag. * Sting and Orcrist will warn of M2_ORC monsters. */A(\"Orcrist\", \"杀兽剑\", ELVEN_BROADSWORD, (SPFX_WARN | SPFX_DFLAG2), 0, M2_ORC, PHYS(5, 0), NO_DFNS, NO_CARY, 0, A_CHAOTIC, NON_PM, PM_ELF, 2000L, CLR_BRIGHT_BLUE); /* bright blue is actually light blue */预期：Excalibur=誓约胜利之剑Stormbringer=兴风者Mjollnir=雷神之锤Cleaver=撕裂者Grimtooth=邪兽之牙Orcrist=杀兽剑查找：替换： 十九. 环视循环提取格式化 在数据处理过程中，经常遇到一些格式化处理，比如简单地将一批数据格式化为SQL（参考9.2），还有复杂的需要对一行数据的某部分进行循环提取，然后格式化为特定格式。12345678910111213141516需求：循环提取每行数据的分支部分和固定部分，格式化为特定格式源串：BBB|CCC|DDD=AAAFFF|GGG|HHH|III|JJJ|KKK=EEE预期：BBB=AAACCC=AAADDD=AAAFFF=EEEGGG=EEEHHH=EEEIII=EEEJJJ=EEEKKK=EEE查找：替换： 二十. 三段论应用 三段论:定锚点，去噪点，取数据。 锚点，在正则中指^、$、\\b这类零宽的位置，这里做了衍生，指能够唯一确定我们目标数据位置的参照点，比如author=lalala，我们要匹配author属性的数据，则author=就是我们的参照点，通过它，我们能快速写出提取author属性的数据的正则：author=(.+)。 噪点，就是对我们提取数据产生干扰的无关数据，我们在做正则匹配提取数据的过程中，可以选择性的忽略它们。当然，这里的忽略不是指不需要对它们做匹配，而是不需要对它们做精确匹配。 数据，这个当然是指我们需要提取的内容了，如上面锚点举例，我们通过author=(.+)的(.+)对lalala部分数据进行了提取，因此，匹配结果的分组1（程序语言中的数组下标1）中，就能得到我们的结果。而对于多个数据的提取，如噪点举例，我们只需要针对数据部分进行多个分组（括号）的提取即可。 分组的计数，一般可以数左括号，排除环视和非捕获组的左括号，从1开始，依次加1递增，1,2,3,4….n，不同语言最大分组个数不同，大家在使用过程中自行留意，不过一般用不了那么多分组。 理解了三段论的概念，我们在写正则的过程中，只需要将源串进行分割划分，根据目标数据确定锚点，过滤噪点，提取数据，就能得到我们想要的正则了。","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www/lyj1215.com/categories/正则表达式/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www/lyj1215.com/tags/正则表达式/"}]},{"title":"正则表达式一","slug":"regex1","date":"2017-09-12T07:41:25.000Z","updated":"2017-09-13T06:27:57.000Z","comments":true,"path":"2017/09/12/regex1/","link":"","permalink":"http://www/lyj1215.com/2017/09/12/regex1/","excerpt":"","text":"认识了解正则表达式也有几年了，每次要用时就百度下如何使用，对于转义到底该用几个’\\’总是弄不清楚，因此想抽出一大块时间来做这件事，彻彻底底的来了解正则，以下内容参考《精通正则表达式》和Zjmainstay学习笔记 相关教程 元字符：一、匹配位置的元字符 ，匹配的是一个位置，而非文本1、脱字符 ^ : 表示匹配行首的文本2、美元符号$ : 表示匹配行尾的文本3、单词分界符 : \\b匹配单词的开始或者结束4、\\B : 匹配不是单词开头或结束的位置 二、匹配计数功能的元字符1、* : 匹配0次到多次2、+ : 匹配一次到多次，最少匹配1次3、？: 匹配0次或者1次4、{min,max} : 匹配min次到max次5、{min,} : 最少匹配min次 三、匹配单个字符的元字符1、[] : 字符组，匹配若干字符之一,匹配被中括号括起来的其中一个，相当于或。 例如gr[ea]y 匹配grey或者gray2、[^x] : 排除型字符组 匹配一个不等于X的字符，“匹配一个未列出的字符”，而不是”不要匹配列出的字符”3、. : 匹配单个任意字符4、\\char : 转义字符5、\\w : 匹配字母或数字或下划线或汉字6、\\s : 匹配任意的空白符7、\\d : 匹配数字8、\\W : 匹配任意不是字母，数字，下划线，汉字的字符9、\\S : 匹配任意不是空白符的字符10、\\D : 匹配任意非数字的字符 四、其他元字符1、| : 匹配任意分隔的表达式，php|java|linux 匹配php或java或者linux ,[]中如果是单个字符，直接写即可，如果是多个字符，则需要用|分开2、() : 一是限定多选结构的范围，而是为反向引用捕获文本3、\\1,\\2 : 反向引用 匹配之前的第一组，第二组括号捕获的文本 五、对以上个别元字符的详细解析：1、脱字符^ ,有两个作用，一个是表示匹配行首的文本，另外一个是排除，在[]里面的是排除的意思，不在[]里面的是匹配行首的意思2、字符组[],H[1-6]等同于H[123456],连字符-只有在[]内才为元字符，在外面为-本意3、转义字符\\char ，一个特殊字符前面加上\\表示转义，特殊字符包括：()[]{}.*+?|\\^$/4、() 括号有多个意思，当作用为限定多选结构的范围时，需要和[]进行区分 (Fri|1)st 匹配first 或1st ，但是Fri|1st就是匹配 Fri或1st","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www/lyj1215.com/categories/正则表达式/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www/lyj1215.com/tags/正则表达式/"}]},{"title":"深拷贝和浅拷贝","slug":"copy","date":"2017-09-08T10:12:41.000Z","updated":"2017-09-08T10:37:37.000Z","comments":true,"path":"2017/09/08/copy/","link":"","permalink":"http://www/lyj1215.com/2017/09/08/copy/","excerpt":"","text":"深拷贝：赋值时完全复制，完全的copy，对其中一个做出改变，不会影响另一个 浅拷贝：赋值时，引用赋值，相当于取了一个别名。对其中一个修改，会影响另一个。 PHP中， = 赋值时，普通对象是深拷贝，但对对象来说，是浅拷贝。也就是说，对象的赋值是引用赋值。（对象作为参数传递时，也是引用传递，无论函数定义时参数前面是否有&amp;符号） php4中，对象的 = 赋值是实现一份副本，这样存在很多问题，在不知不觉中我们可能会拷贝很多份副本。 php5中，对象的 = 赋值和传递都是引用。要想实现拷贝副本，php提供了clone函数实现。 clone完全copy了一份副本。但是clone时，我们可能不希望copy源对象的所有内容，那我们可以利用__clone来操作。 在clone（）中，我们可以进行一些操作。注意，这些操作，也就是clone函数是作用于拷贝的副本对象上的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364实现对象这种的深拷贝，有两种方法：例子1：重写clone函数&lt;?phpclass Test&#123; public $a=1;&#125; class TestOne&#123; public $b=1; public $obj; //包含了一个对象属性，clone时，它会是浅拷贝 public function __construct()&#123; $this-&gt;obj = new Test(); &#125; //方法一：重写clone函数 public function __clone()&#123; $this-&gt;obj = clone $this-&gt;obj; &#125;&#125; $m = new TestOne();$n = clone $m; $n-&gt;b = 2;echo $m-&gt;b;//输出原来的1echo PHP_EOL;//可以看到，普通属性实现了深拷贝，改变普通属性b，不会对源对象有影响 //由于改写了clone函数，现在对象属性也实现了真正的深拷贝，对新对象的改变，不会影响源对象$n-&gt;obj-&gt;a = 3;echo $m-&gt;obj-&gt;a;//输出1，不随新对象改变，还是保持了原来的属性 例子2：序列化和反序列化class Test&#123; public $a=1;&#125; class TestOne&#123; public $b=1; public $obj; //包含了一个对象属性，clone时，它会是浅拷贝 public function __construct()&#123; $this-&gt;obj = new Test(); &#125; &#125; $m = new TestOne();//方法二，序列化反序列化实现对象深拷贝$n = serialize($m);$n = unserialize($n); $n-&gt;b = 2;echo $m-&gt;b;//输出原来的1echo PHP_EOL;//可以看到，普通属性实现了深拷贝，改变普通属性b，不会对源对象有影响 $n-&gt;obj-&gt;a = 3;echo $m-&gt;obj-&gt;a;//输出1，不随新对象改变，还是保持了原来的属性,可以看到，序列化和反序列化可以实现对象的深拷贝 例子3：json_encode之后再json_decode,实现赋值","categories":[{"name":"设计模式","slug":"design-mode","permalink":"http://www/lyj1215.com/categories/design-mode/"}],"tags":[{"name":"设计模式","slug":"design-mode","permalink":"http://www/lyj1215.com/tags/design-mode/"}]},{"title":"laravel框架中常用PHP语法","slug":"laravel-3","date":"2017-09-08T01:51:06.000Z","updated":"2017-09-08T02:57:00.000Z","comments":true,"path":"2017/09/08/laravel-3/","link":"","permalink":"http://www/lyj1215.com/2017/09/08/laravel-3/","excerpt":"","text":"一、文件包含1.include与require 共同点：include与require关键字用于包含并运行指定文件。 不同点：两者作用几乎一样，只是处理失败的方式不同。require在出错时产生E_COMPILE_ERROR级别的错误，因此会导致脚本程序运行终止，而include则是会产生E_WARNING级别错误，只会发出警告，而脚本程序会继续运行。 查找路径的方式12345678910if(如果定义了路径，不管绝对路径还是相对路径)&#123; include_path会被忽略，按参数给出的路径寻找；&#125;else if(只有文件名，没有目录名)&#123; 则按照include_path指定的目录寻找；&#125;else if(include_path没有)&#123; 在调用脚本所在的目录和当前工作目录下寻找&#125;else&#123; Include 发出一条警告，require发生一个致命错误&#125; include查找路径的方式比较，推荐由高到低 通过当前路径查找，好处是迁移到别的项目时什么都不用改 使用include_path，即默认路径，迁移项目是需要改php.ini 绝对路径，迁移项目时需要改代码 相对路径，迁移项目时什么都不用改，但是为什么不推荐，是因为当被多人include时，会存在bug1).文件存储如下图所示，当a.php include b.php，c.php include a.php2).当单独访问a.php没有问题，但是访问c.php就会报错，找不到b.php 如果包含了一个定义了路径的文件，如include “../file.php”,无论是相对路径还是绝对路径，系统只会在相应的路径下寻找该文件，例如一个文件以“../”开头，则解析器会在当前目录的父目录下寻找该文件。当一个文件被包含时，包含文件则继承了被包含文件拥有的变量，从该处开始，被包含文件可用的任何变量在包含的文件中也都可用，同时在被包含文件中定义的函数，类或者常量都具有全局作用域。 2.类的自动加载3.laravel中的实现 注：以上内容参考《PHP手册》和《laravel框架关键技术解析》以及laravel源代码","categories":[{"name":"框架分析","slug":"框架分析","permalink":"http://www/lyj1215.com/categories/框架分析/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://www/lyj1215.com/tags/laravel/"}]},{"title":"UML类图关系总结","slug":"uml","date":"2017-09-07T14:18:11.000Z","updated":"2017-09-08T06:58:08.000Z","comments":true,"path":"2017/09/07/uml/","link":"","permalink":"http://www/lyj1215.com/2017/09/07/uml/","excerpt":"","text":"在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency) 一、泛化（Generalization）【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。【箭头指向】：带三角箭头的实线，箭头指向父类 二、实现（Realization）【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现.【箭头指向】：带三角箭头的虚线，箭头指向接口 三、关联（Association)【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。【代码体现】：成员变量【箭头及指向】：带普通箭头的实心线，指向被拥有者 上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。 下图为自身关联： 四、聚合（Aggregation）【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。【代码体现】：成员变量【箭头及指向】：带空心菱形的实心线，菱形指向整体 五、组合(Composition)【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。【代码体现】：成员变量【箭头及指向】：带实心菱形的实线，菱形指向整体 六、依赖(Dependency)【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.【代码表现】：局部变量、方法的参数或者对静态方法的调用【箭头及指向】：带箭头的虚线，指向被使用者 各种关系的强弱顺序： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 下面这张UML图，比较形象地展示了各种类图关系： 转自：http://blog.csdn.net/tianhai110/article/details/6339565","categories":[{"name":"设计模式","slug":"design-mode","permalink":"http://www/lyj1215.com/categories/design-mode/"}],"tags":[{"name":"设计模式","slug":"design-mode","permalink":"http://www/lyj1215.com/tags/design-mode/"},{"name":"UML","slug":"UML","permalink":"http://www/lyj1215.com/tags/UML/"}]},{"title":"SQL注入","slug":"sql-injection","date":"2017-09-07T14:01:39.000Z","updated":"2017-09-13T07:28:49.000Z","comments":true,"path":"2017/09/07/sql-injection/","link":"","permalink":"http://www/lyj1215.com/2017/09/07/sql-injection/","excerpt":"","text":"一、目的简介 让这些输入被认为是一个SQL查询，或者是查询的一部分,针对程序员编程的忽略通过SQL语句，实现无账号登录甚至篡改数据库。 二、SQL注入攻击的总体思路： 寻找到SQL注入的位置 判断服务器类型和后台数据库类型 针对不同的服务器和数据库特点进行SQL注入攻击 三、SQL注入攻击实例1234567免账号登录：sql = \"select * from user_table where username=' \"+userName+\" ' and password=' \"+password+\" '\";当用户输入的用户名为 ‘or 1=1 --sql = \"select * from user_table where username=‘’ or 1=1 -- ' and password=' \"+password+\" ‘\";由于1=1肯定会成功 ，--是注释后面的语句不用执行，因此不用账号密码就可以登录成功。当用户输入的用户名为 ' ;DROP DATABASE (DB Name) —'以上语句则会删除数据库 四、防范： 服务器配置防范 关闭注册全局变量，在PHP中提交的变量，包括post或者get提交的变量，都将自动注册为全局变量，能够直接访问，对服务器是不安全的，所以应该关闭 register_globals=off 打开magic_quotes_gpc 防止SQL注入。 默认是关闭的，如果打开后将自动把用户提交对SQL的查询进行转换，比如把’ 转为\\’ 等 错误信息控制 一般数据库会在没有连接到数据库或者在其他情况下会有提示错误，一般错误信息中会包含PHP脚本当前的路径信息或者查询的SQL语句信息，因此display_errors = off ，关闭错误信息后把错误日志打开 PHP方法： addslashes() 强行加\\ mysql_real_escape_string()会判断字符集，但是对PHP版本有要求 mysql_escape_string() 不考虑连接的当前字符集","categories":[{"name":"安全","slug":"安全","permalink":"http://www/lyj1215.com/categories/安全/"}],"tags":[{"name":"安全，SQL注入","slug":"安全，SQL注入","permalink":"http://www/lyj1215.com/tags/安全，SQL注入/"}]},{"title":"MySQL执行顺序","slug":"mysql","date":"2017-09-07T13:52:19.000Z","updated":"2017-09-07T13:58:28.000Z","comments":true,"path":"2017/09/07/mysql/","link":"","permalink":"http://www/lyj1215.com/2017/09/07/mysql/","excerpt":"","text":"FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1 ON: 对虚表VT1进行ON筛选，只有那些符合的行才会被记录在虚表VT2中。 JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。 WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合的记录才会被插入到虚拟表VT4中。 GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5. CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6. HAVING： 对虚拟表VT6应用having过滤，只有符合的记录才会被 插入到虚拟表VT7中。 SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。 DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9. ORDER BY: 将虚拟表VT9中的记录按照进行排序操作，产生虚拟表VT10. LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www/lyj1215.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www/lyj1215.com/tags/MySQL/"}]},{"title":"常见查找算法","slug":"search","date":"2017-07-16T15:30:07.000Z","updated":"2017-07-16T15:30:07.000Z","comments":true,"path":"2017/07/16/search/","link":"","permalink":"http://www/lyj1215.com/2017/07/16/search/","excerpt":"","text":"查找定义：根据给定的某个值，在查找表中确定一个七关键字等于给定值得数据元素。 查找算法分类： 静态查找和动态查找 有序查找和无序查找 平均查找长度 查找算法分类： 1）静态查找和动态查找； 注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。 2）无序查找和有序查找。 无序查找：被查找数列有序无序均可； 有序查找：被查找数列必须为有序数列。 平均查找长度（Average Search Length，ASL）：需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。 对于含有n个数据元素的查找表，查找成功的平均查找长度为：ASL = Pi*Ci的和。 Pi：查找表中第i个数据元素的概率。 Ci：找到第i个数据元素时已经比较过的次数。 一、顺序查找思路：一个一个的查复杂度：o(n)代码：12345678910111213141516171819202122232425262728function seqSearch($arr,$k)&#123; for($i=0;$i&lt;count($arr);$i++)&#123; if($arr[$i] == $k)&#123; return $i; &#125; &#125; return false;&#125;$items=[1,3,5,7,9,11,13,15];var_dump(seqSearch($items, 4));var_dump(seqSearch($items, 5));示例2：// $array为数组，$k为要查找的值 function search2 ($array, $val )&#123; $array[]=$val; $n = count($array); $i = 0; while( $array[$i] != $val )&#123; $i++; &#125; return ($i == $n-1) ? false : $i;&#125;$items=[32,55,6,33,921,543,123,666];var_dump(search2($items, 4));var_dump(search2($items, 55)); 二、二分查找思路：也称为是折半查找，属于有序查找算法。需要设定三个值，low=0；high=count-1;mid=(low+high)/2,用给定值k先与mid的关键字比较，若相等则查找成功；若mid值比k值大，则去查找前半部分，high=mid-1;若mid值比K值小，则去查找后半部分，low=mid+1;循环比较，直到mid==k,循环条件：low&lt;=high说明：必须是有序的，如果不是有序的可以先排序一下复杂度：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；代码：1234567891011121314151617181920function binarySearch($arr,$k)&#123; $len = count($arr); $low = 0; $high = $len-1; while($low &lt;= $high) &#123; $mid = intval(($low + $high) / 2); if ($arr[$mid] == $k) &#123; return $mid; &#125; elseif ($arr[$mid] &gt; $k) &#123; $high = $mid-1; &#125; else &#123; $low = $mid+1; &#125; &#125; return false;&#125;$array = array(2,3,4,7,9,10,11,18,19,20,33);var_dump(binarySearch($array,7)); 三、插值查找思路：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。mid=low+(key-a[low])/(a[high]-a[low])*(high-low)说明：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。 复杂度：查找成功或者失败的时间复杂度均为O(log2(log2n))。代码：12345678910111213141516171819202122232425function binarySearch ($array, $val )&#123; $low=0; $high=count($array)-1; while( $low&lt;=$high )&#123; if($low==$high)&#123; $mid=$low; &#125;else&#123; $mid= $low +( ( $val -$array[$low] )/( $array[$high]-$array[$low] ) ) * ( $high - $low ) ; if($mid&lt;0)return false; &#125; if( $val&lt;$array[$mid] )&#123; $high=$high-1; &#125;else if( $val&gt;$array[$mid] )&#123; $low=$low+1; &#125;else&#123; return $mid; &#125; &#125; return false;&#125;$items=[1,3,5,7,9,11,13,15];var_dump(binarySearch($items, 4));var_dump(binarySearch($items, 5));","categories":[{"name":"数据结构与算法","slug":"algorithm","permalink":"http://www/lyj1215.com/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www/lyj1215.com/tags/算法/"}]},{"title":"常用地址","slug":"used-address","date":"2017-03-17T05:16:04.000Z","updated":"2017-07-23T11:16:04.000Z","comments":true,"path":"2017/03/17/used-address/","link":"","permalink":"http://www/lyj1215.com/2017/03/17/used-address/","excerpt":"","text":"学习 编程书籍大全 https://github.com/justjavac/free-programming-books-zh_CN 廖雪峰官方网站 https://www.liaoxuefeng.com/ 牛客网 https://www.nowcoder.com/ PHP之道 https://laravel-china.github.io/php-the-right-way/ 啊哈磊算法 http://ahalei.blog.51cto.com/ PHP手册 http://php.net/manual/zh/index.php 深入PHP内核 http://www.php-internals.com/book/ 实验楼 https://www.shiyanlou.com/ 工具 json校验 http://www.bejson.com/ 时间戳转换 http://tool.chinaz.com/Tools/unixtime.aspx 正则表达式在线验证 http://regex.zjmainstay.cn/ PHP模拟器 https://3v4l.org/BIsAB 在线流程图 https://www.processon.com/ 住房公积金 http://www.bjgjj.gov.cn/ 社保查询 http://www.bjrbj.gov.cn/csibiz/home/#","categories":[{"name":"其他","slug":"其他","permalink":"http://www/lyj1215.com/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://www/lyj1215.com/tags/其他/"}]},{"title":"单例模式","slug":"singleton","date":"2017-03-16T13:40:35.000Z","updated":"2017-03-16T15:30:07.000Z","comments":true,"path":"2017/03/16/singleton/","link":"","permalink":"http://www/lyj1215.com/2017/03/16/singleton/","excerpt":"","text":"一、概览 设计原则：无 常用场景：应用中有对象需要是全局的且唯一 使用概率：99.99999% 复杂度：低 变化点：无 选择关键点：一个对象在应用中出现多个实例是否会引起逻辑上或者是程序上的错误 逆鳞：在以为是单例的情况下，却产生了多个实例 相关设计模式： 原型模式：单例模式是只有一个实例，原型模式每拷贝一次都会创造一个新的实例。 二、定义：单例模式：单例模式保证一个类只有一个实例，同时这个类还必须提供一个访问该类的全局访问点。 三、UML类图 单例模式的三个要点： 需要一个保存类的唯一实例的静态成员变量 构造函数和克隆函数必须私有 必须提供一个访问这个实例的公共静态方法，从而返回唯一实例的一个引用 那么为什么要使用PHP单例模式？ PHP一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，使用单例模式可以避免大量的new操作。因为每一次new操作都会消耗系统和内存的资源。 单例模式代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php/** * class Singleton */class Singleton&#123; /** * @var Singleton reference to singleton instance */ private static $instance; /** * gets the instance via lazy initialization (created on first usage) * * @return self */ public static function getInstance() &#123; if (null === static::$instance) &#123; static::$instance = new static; //static 相当于self &#125; return static::$instance; &#125; /** * is not allowed to call from outside: private! * */ private function __construct() &#123; &#125; /** * prevent the instance from being cloned * * @return void */ private function __clone() &#123; &#125; /** * prevent from being unserialized * * @return void */ private function __wakeup() &#123; &#125;&#125; 单例模式优缺点：优点： 由于在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁的创建，销毁时 减少了系统的性能开销，读取配置，产生其他依赖对象时，可以通过在应用启动时直接产生一个单例对象。 可以避免对资源的多重占用，比如写文件动作，由于只有一个实例在内存中，可以避免对同一个资源文件的同时写操作 可以在系统设置全局的访问点，优化和共享资源访问，可以设计一个单例类，负责所有的数据表的映射处理缺点：1.一般没有接口，扩展困难，","categories":[{"name":"设计模式","slug":"design-mode","permalink":"http://www/lyj1215.com/categories/design-mode/"}],"tags":[{"name":"设计模式","slug":"design-mode","permalink":"http://www/lyj1215.com/tags/design-mode/"},{"name":"单例","slug":"单例","permalink":"http://www/lyj1215.com/tags/单例/"}]},{"title":"awk学习","slug":"awk","date":"2017-03-08T10:17:23.000Z","updated":"2017-03-08T10:17:23.000Z","comments":true,"path":"2017/03/08/awk/","link":"","permalink":"http://www/lyj1215.com/2017/03/08/awk/","excerpt":"","text":"awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。使用方法：awk ‘{pattern + action}’ {filenames} 一、书写格式： 命令行格式 awk -F”:” ‘{print $2}’ test.txt 使用较多 文本格式#!/usr/bin/awkBEGIN {FS=”:”}{print $1} 以上为写好的文本格式file.awk执行.awk文件的命令为：awk -f file.awk test.txt 二、变量：常用内置变量 $0 全部内容 $1~$n 被分割的第n个字符 FS 分隔符（默认为空格） RS 输入记录的分隔符(默认为空格) NF 字段个数 NR 行号自定义及外部变量 awk -v name=$myname ‘BEGIN{print name}’ $myname 是自己定义的变量 awk -v host=$HOSTNAME ‘BEGIN{print host}’ $HOSTNAME 是系统变量 awk -v name=‘lalalal’ ‘BEGIN{print name}’ 还可以直接定义 三、操作符 ~ 匹配匹配第7列中是以/bin开头的文件并输出╰─&gt;awk -F: ‘$7 ~ /^\\/bin/{print $0}’ /etc/passwd 17-08-16 11:04root::0:0:System Administrator:/var/root:/bin/sh_mbsetupuser::248:248:Setup User:/var/setup:/bin/bash !~ 不匹配匹配第7列中不是以/bin开头的文件并输出╰─&gt;awk -F: ‘$7 !~ /^\\/bin/{print $0}’ /etc/passwd 四、输出 print:直接打印 printf:格式化打印 五、流程控制 if seq 10 | awk ‘{if($0%2==0){print “ok”}else{print”no”}}’ while 给etc/passwd 中的每一个字段都加上序号╭─◆liuyajuan@liuyajuandeMacBook-Pro.local/Users/liuyajuan/Downloads╰─&gt;awk -F: ‘{i=1;while(i&lt;=NF){printf(“ %d:%s “,i,$i);i++}{print “ “ }}’ /etc/passwd for 六、BEGIN ,END作用:给程序赋予初始化状态和在程序结束之后执行一些扫尾工作。 任何在BEGIN之后列出的操作（在{}内）将在Unix awk开始扫描输入之前执行 而END之后列出的操作将在扫描完全部的输入之后执行 因此，通常使用BEGIN来显示变量和预置（初始化）变量，使用END来输出最终结果。 七、练习题：1、截取IP地址╭─◆liuyajuan@liuyajuandeMacBook-Pro.local/Users/liuyajuan╰─&gt;ifconfig en0 17-08-16 10:10en0: flags=8963 mtu 1500 ether ac:bc:32:bf:5e:d9 inet 169.254.198.146 netmask 0xffff0000 broadcast 169.254.255.255 nd6 options=201 media: autoselect status: active╭─◆liuyajuan@liuyajuandeMacBook-Pro.local/Users/liuyajuan╰─&gt;ifconfig en0 | awk -F ‘ ‘ ‘/inet / {print $2}’ 17-08-16 10:11169.254.198.146","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www/lyj1215.com/categories/Linux/"}],"tags":[{"name":"awk","slug":"awk","permalink":"http://www/lyj1215.com/tags/awk/"}]},{"title":"git使用","slug":"git","date":"2017-01-05T04:00:33.000Z","updated":"2017-01-05T04:00:33.000Z","comments":true,"path":"2017/01/05/git/","link":"","permalink":"http://www/lyj1215.com/2017/01/05/git/","excerpt":"","text":"看完廖雪峰老师的git教程后，对git的使用有所了解，因此整理一下，作为参考 https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 一、Git简介1. Git的诞生2. 集中式vs分布式 集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。 那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 二、安装Git12以下是Mac下的安装└─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; brew install git 三、创建版本库 版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 12345678└─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; mkdir learnGit└─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; cd learnGit└─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; pwd/Users/liuyajuan/Sites/learnGit└─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; git init //利用git init 把这个目录变成Git可以管理的仓库，会发现当前目录下多了一个.git的目录//把文件添加到版本库的方法：└─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; git add test.txt //git add 添加文件└─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; git commit -m 'wrote a test file' // -m '' 是输入提交的说明，方便能从历史记忆里很快的找到需要的内容 初始化一个Git仓库，使用 git init 命令。 添加文件到Git仓库，分两步： 第一步，使用命令 git add ，注意，可反复多次使用，添加多个文件； 第二步，使用命令 git commit，完成。 四、时光机穿梭1. 版本回退 1.git status 查看哪些文件被修改，可以随时掌握工作区的状态 2.git diff 查看修改的内容 3.HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令 git reset –hard commit_id。 4.穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 5.要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 2. 工作区和暂存区 以上的learnGit就是我的工作区，工作区有一个隐藏的目录.git,这个就是Git的版本库版本库中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 3. 管理修改 Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 4.撤销修改 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 5.删除文件 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 五、远程仓库1. 添加远程库 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 2. 从远程库克隆 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 六、分支管理1. 创建与合并分支 1.查看分支：git branch2.创建分支：git branch 3.切换分支：git checkout 4.创建+切换分支：git checkout -b 5.合并某分支到当前分支：git merge 6.删除分支：git branch -d 2. 解决冲突 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 用git log –graph命令可以看到分支合并图。 3. 分支管理策略 Git分支十分强大，在团队开发中应该充分应用。 合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并 4. Bug分支 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 5. Feature分支 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。 6.多人协作 1.查看远程库信息，使用git remote -v；2.本地新建的分支如果不推送到远程，对其他人就是不可见的；3.从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；4.在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；5.建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；6.从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 七、标签管理1. 创建标签 1.命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； 2.git tag -a -m “blablabla…” 可以指定标签信息； 3.git tag -s -m “blablabla…”可以用PGP签名标签； 4.命令git tag可以查看所有标签。 2. 操作标签 1.命令git push origin 可以推送一个本地标签； 2.命令git push origin –tags 可以推送全部未推送过的本地标签； 3.命令git tag -d 可以删除一个本地标签； 4.命令git push origin :refs/tags/ 可以删除一个远程标签 八、自定义git 1.忽略某些文件时，需要编写.gitignore;.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！ └─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; git config –global alias.co checkout └─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; git config –global alias.ci commit └─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; git config –global alias.br branch └─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; git config –global alias.st status └─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; git config –global alias.last ‘log -1’","categories":[{"name":"其他","slug":"其他","permalink":"http://www/lyj1215.com/categories/其他/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www/lyj1215.com/tags/git/"}]},{"title":"hexo相关配置以及遇到的问题","slug":"hexo2","date":"2016-12-11T11:20:33.000Z","updated":"2016-12-11T11:20:33.000Z","comments":true,"path":"2016/12/11/hexo2/","link":"","permalink":"http://www/lyj1215.com/2016/12/11/hexo2/","excerpt":"","text":"一、如何统计阅读量 对着配置看了半天都不知道该去如何设置文章的点击数,看如下的配置阅读量统计也是开启的，怎么不能页面不能显示呢，后来百度才发现是自己太天真了，原来leancloud是需要去注册才能使用的😂😂😂 12345678910## leancloud --- leancloud 阅读量统计## &#123;@leancloud:&#123;enable:是否开启,className:创建的class,app_id:,app_key:,region:默认为中国地区,limits:热门文章显示总数&#125;&#125;leancloud: enable: true className: \"baseCounter\" app_id: '' app_key: '' region: limits: 10 注册LeanCloud，这里不再赘述创建应用 创建阅读统计表 获取AppID和AppKey 更改配置 12345678910## leancloud --- leancloud 阅读量统计## &#123;@leancloud:&#123;enable:是否开启,className:创建的class,app_id:,app_key:,region:默认为中国地区,limits:热门文章显示总数&#125;&#125;leancloud: enable: true className: \"创建的名字\" app_id: '刚刚拷贝的app_id' app_key: '刚刚拷贝的app_key' region: limits: 10 二、如何在文章中插入图片其实这里就是markdown的语法了，无奈我不会，因此边学边用图片的语法和链接很像。 123456789101112131415 行内形式（title 是选择性的）：![alt text](/path/to/img.jpg \"Title\")参考形式：![alt text][id][id]: /path/to/img.jpg \"Title\"上面两种方法都会输出 HTML 为：&lt;img src=\"/path/to/img.jpg\" alt=\"alt text\" title=\"Title\" /&gt;","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://www/lyj1215.com/categories/环境搭建/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www/lyj1215.com/tags/hexo/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://www/lyj1215.com/tags/环境搭建/"}]},{"title":"hexo+github搭建免费网站","slug":"hexo","date":"2016-12-10T11:20:33.000Z","updated":"2016-12-10T11:20:33.000Z","comments":true,"path":"2016/12/10/hexo/","link":"","permalink":"http://www/lyj1215.com/2016/12/10/hexo/","excerpt":"","text":"一、准备工作 一个github账号 安装node.js(node官网下载)、npm(推荐brew安装) 安装git 二、在GitHub创建仓库 新建一个名为你的用户名.github.io的仓库 仓库名字必须是：username.github.io，其中username是你的用户名 三、安装hexo Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网：http://hexo.io github: https://github.com/hexojs/hexo 安装 npm install -g hexo 初始化 在电脑的某个地方新建一个名为blog的文件夹（名字可以随便取），我的是~/Sites/blog,进入目录执行 hexo init至此hexo安装完毕 四、本地运行 在项目根目录下执行 hexo s #启动服务 访问：http://localhost:4000 五、配置git 编辑 根目录下的 _config.yml 文件12345deploy: type: git repo: https://github.com/username/username.github.io #username就是你的用户名 branch: master message: 提交博客内容 安装插件 npm install hexo-deployer-git –save 提交 hexo d 如果提交失败需要清除 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 六、下载好看的主题和有用的插件 Plugins: https://hexo.io/plugins/ Themes: https://hexo.io/themes/ 主题里面自带使用教程这里就不多说了 七、绑定域名(依据个人情况) 如果不绑定域名肯定也是可以的，就用默认的 xxx.github.io 来访问 阿里云购买域名后 执行ping xxx.github.com得到对应的IP地址，去万网的控制台中解析购买的域名 在blog/source 目录下新建一个CNAME文件(无后缀名) 将自己的域名 www.lxzfranky.com填入其中,至此自己的博客基本已经完成 八、其他一些设置 详见根目录下的 _config.yml,另外会单独写一篇文章来讲解如何设置 九、开始你的博客之旅吧 到根目录下执行如下命令hexo会帮我们在_posts下生成相关md文件，打开这个文件编辑就好了 12345678910执行hexo new 'first'命令打开文件如下：---title: postName #文章页面上的显示名称，一般是中文date: 2017-07-07 19:39:39 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文 十、hexo一些常用命令 基本命令 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 缩写 hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 命令组合 hexo s -g #生成并本地预览 hexo d -g #生成并上传","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://www/lyj1215.com/categories/环境搭建/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www/lyj1215.com/tags/hexo/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://www/lyj1215.com/tags/环境搭建/"}]},{"title":"第一篇博客诞生","slug":"first","date":"2016-11-06T10:42:37.000Z","updated":"2016-11-06T10:42:37.000Z","comments":true,"path":"2016/11/06/first/","link":"","permalink":"http://www/lyj1215.com/2016/11/06/first/","excerpt":"","text":"从此开启了博客之路，发布第一篇作为纪念！","categories":[{"name":"杂文","slug":"other","permalink":"http://www/lyj1215.com/categories/other/"}],"tags":[{"name":"杂文","slug":"other","permalink":"http://www/lyj1215.com/tags/other/"}]}]}