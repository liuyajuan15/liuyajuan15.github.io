---
title: 正则表达式基本介绍
date: 2017-09-12 15:41:25
tags: 正则表达式
categories: 正则表达式
---
> 认识了解正则表达式也有几年了，每次要用时就百度下如何使用，对于转义到底该用几个'\'总是弄不清楚，因此想抽出一大块时间来做这件事，彻彻底底的来了解正则，以下内容参考《PHP手册》和《精通正则表达式》和[Zjmainstay学习笔记](http://www.zjmainstay.cn/my-regexp) 相关教程

### 一、元字符：

##### 一、匹配位置的元字符 ，<a>匹配的是一个位置，而非文本</a>

1. 脱字符 ^ : 表示匹配行首的文本
2. 美元符号$ : 表示匹配行尾的文本
3. 单词分界符 : \b匹配单词的开始或者结束
4. \B : 匹配不是单词开头或结束的位置

##### 二、匹配计数功能的元字符

1. * : 匹配0次到多次   **匹配优先量词*，匹配尽可能多的内容*
2. + :  匹配一次到多次，最少匹配1次 **匹配优先量词*，匹配尽可能多的内容*
3. ？: 匹配0次或者1次 **匹配优先量词*，匹配尽可能多的内容*
4. {min,max} : 匹配min次到max次 **匹配优先量词*，匹配尽可能多的内容*
5. {min,} : 最少匹配min次
6. *?,+?,??,{min,max}?  **忽略优先量词，匹配尽可能少的内容，跟非贪婪模式有关**
7. *+,++,?+,{min,max}+  **占有优先量词，类似普通匹配优先，一旦匹配某些内容，就不会交还，类似固化分组**

##### 三、匹配单个字符的元字符

1. [] : 字符组，匹配若干字符之一,匹配被中括号括起来的其中一个，相当于或。 例如gr[ea]y 匹配grey或者gray
2. [^x] : 排除型字符组 匹配一个不等于X的字符，<a>"匹配一个未列出的字符"，而不是"不要匹配列出的字符"</a>
3. . : 匹配单个任意字符
4. \char : 转义字符
5. \w : 匹配字母或数字或下划线或汉字
6. \s : 匹配任意的空白符
7. \d : 匹配数字
8. \W : 匹配任意不是字母，数字，下划线，汉字的字符
9. \S : 匹配任意不是空白符的字符
10. \D : 匹配任意非数字的字符

##### 四、其他元字符

1. | : 匹配任意分隔的表达式，php|java|linux 匹配php或java或者linux ,[]中如果是单个字符，直接写即可，如果是多个字符，则需要用|分开
2. () : 一是限定多选结构的范围，而是为反向引用捕获文本
3. \1,\2 : 反向引用 匹配之前的第一组，第二组括号捕获的文本

##### 五、对以上个别元字符的详细解析：

1. 脱字符^ ,有两个作用，一个是表示匹配行首的文本，另外一个是排除，在[]里面的是排除的意思，不在[]里面的是匹配行首的意思
2. 字符组[],H[1-6]等同于H[123456],连字符-只有在[]内才为元字符，在外面为-本意
3. 转义字符\char ，一个特殊字符前面加上\表示转义，特殊字符包括：()[]{}.*+?|\^$/
4. () 括号有多个意思，详细内容见以下的分组捕获，当作用为限定多选结构的范围时，需要和[]进行区分 (Fri|1)st 匹配first 或1st ，但是Fri|1st就是匹配 Fri或1st

### 二、模式修饰符：

>PHP模式修饰符又叫模式修正符，是在正则表达式的定界符之外使用。主要用来调整正则表达式的解释，提扩展了正则表达式在匹配、替换等操作的某些功能，增强了正则的能力。

1. i **不区分大小写**，(?i) 如果设置了这个修饰符，'a'和'A'是一样的。
2. s **单行模式**，(?s)如果设定了这个修正符，那么，被匹配的字符串将视为一行来看，包括换行符，换行符将被视为普通字符串。
3. m **多行匹配模式**，(?m)将字符串视为多行。默认的正则开始“^”和结束“$”将目标字条串作为一单一的一“行”字符（甚至其中包括换行符也是如此）。如果在修饰符中加上“m”，那么开始和结束将会指点字符串的每一行的开头就是“^”结束就是“$”。
4. x **忽略空白**，(?x)正则表达式中的“空白字符”和“换行符”将会被忽略，除非它已经被转义，同时#号（#）被解释为注释的开头
5. e 只用在preg_replace()函数中，在替换字符串中逆向引用做正常的替换，将其(即“替换字符串”)作为PHP代码求值，并用其结果来替换所搜索的字符串。
6. A 如果使用这个修饰符，那么表达式必须是匹配的字符串中的开头部分。比如说”/a/A”匹配”abcd”。
7. D 模式中的$字符权匹配目标字符的结尾。没有此选项时，如果最后一个字符是换行符的话，美元符号也会匹配此字符之前。如果设定了修正符m则忽略此项。
8. E 与”m”相反，如果使用这个修饰符，那么”$”将匹配绝对字符串的结尾，而不是换行符前面，默认就打开了这个模式。
9. U **设置贪婪模式**，(?U)和问号的作用差不多，最大限度的匹配就是贪婪模式。 **贪婪模式会有一篇单独的笔记来记录**

```php
//不区分大小写 i
$s = "First line Second LINE";
preg_match_all("/line/i",$s,$m);
print_r($m); //Array ( [0] => Array ( [0] => line [1] => LINE ) )

//多行匹配模式 m
$s = "First line\nSecond line";
preg_match_all("/^\w/m",$s,$m);
print_r($m);//Array ( [0] => Array ( [0] => F [1] => S ) )

//单行匹配模式 s
$s = "First line\nSecond line";
preg_match_all("/^\w/s",$s,$m);
print_r($m); //Array ( [0] => Array ( [0] => F ) )

//忽略正则表达式中的“非转义的空白字符”和“回车换号符”
$p = "abc #category code\n123 #item number";
$s = "abc123";
preg_match_all("/".$p."/x",$s,$m);
var_dump($m); //abc123，相当于匹配abc123

//必须是字符串中的开头部分A
$s = "abcba";
preg_match_all("/a/A",$s,$m); //a

$s = "abcba";
preg_match_all("/a/",$s,$m); //两个a都会被匹配到
```

>部分修饰符还可以用于表达式内部
* (?i)用来启用不区分大小写的匹配，(?-i)停用，此时，他们的作用范围持续到对应的括号结束

### <a name="fenzu">三、分组捕获</a>

>()在正则中有两种用途：分组和捕获

1. 普通捕获 **(pattern)** 匹配pattern并捕获结果，自动设置组号
2. 命名捕获 **(?\<name\>pattern) 或者 (?'name'pattern)**  匹配pattern并捕获结果，设置name为组名，普通捕获的0，1，2，数字还会捕获到
3. 普通捕获组的反向引用 **\1,\2** ,(\w)(\d)\2\1,匹配a11a
4. 命名捕获组的反向引用  **\k\<name\> 或者 \k'name'**  (?\<group\>\d)abc\k\<group\> 匹配1abc1
5. 非捕获型括号**(?:exp)**,仅用于分组，不能用来提取文本，只能用来规定多选结构或者量词的作用对象 (1|one)(?:and|or)(2|two) 匹配之后，$1包含1或者one ,$2包含2或者two
6. 固化分组(?<)
7. 让多个子组可以共用一个后向引用数字(?|)
**(?| 语法允许复制数字。 考虑下面的正则表达式匹配Sunday：
(?:(Sat)ur|(Sun))day
这里当后向引用 1 空时Sun 存储在后向引用 2 中. 当后向引用 2 不存在的时候 Sat 存储在后向引用 1中。 使用 (?|修改模式来修复这个问题：
(?|(Sat)ur|(Sun))day
使用这个模式， Sun和Sat都会被存储到后向引用1中。**
