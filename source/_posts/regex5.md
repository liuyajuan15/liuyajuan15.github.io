---
title: PHP中的正则
date: 2017-09-19 14:26:49
tags: [正则表达式,PHP]
categories: 正则表达式

---
### 一、PHP的特性和流派
详细内容见：http://lyj1215.com/2017/09/12/regex1/

**字符缩略表示法**

* \a警报,\b退格（在字符组内部支持，外部是单词分界符）,\eEscape字符,\f进制符,\n,\r,\t,

**字符组及相关结构**

* 字符组[...][^...]
* 几乎任何字符 点号
* 字符组缩略表示法 \w,\d,\s,\W,\D,\S
* Unicode混合序列\X ,只能与模式修饰符u连用
* Unicode属性和区块\p{Prop},\P{Prop} ，可用于字符组内部，只能与模式修饰符u连用

**锚点及其他零长度断言**

*  **行/字符串起始位置** ^ \A   正常情况：^匹配字符串起始位置;增强型行锚点模式：^还可以匹配任何换行符之后的位置，\A总是和^一样
* **行字符串结束位置** $ \Z \z 正常情况：$匹配字符串的结束位置，匹配字符串结尾的换行符；增强型行锚点模式：$匹配字符串的末尾，匹配**任何**换行符之前的位置。\Z 总是和普通的$一样，\z总是匹配字符串的末尾。
* **当前匹配的起始位置**  \G
* **单词分界符** \b \B
* **环视结构** (?=exp) (?!exp) (?<=exp) (?<!exp)  详细信息见：http://lyj1215.com/2017/09/12/regex4/

**注释及模式修饰符**

*  **表达式内部模式修饰符** (?i),允许出现的有 i,m,s ,x,U,X  ,
*  **模式修饰范围**（?i:）
*  **注释** (?#...),只在模式修饰符x下有效

**分组及捕获**

* **捕获型括号**(...)  反向引用 \1 \2
* **命名捕获** (?\<name\>) 或者(?'name')     反向引用 \k\<name\>或者 \k 'name'
* **非捕获型** (?:exp)
* **让多个子组可以共用一个后向引用数字** (?|)
*  **固化分组**
*  **匹配优先量词**  *,+,?,{n},{n,},{x,y}
*  **忽略优先量词** *?,+?,??,{n}?,{n,}?,{x,y}?
*  **占有优先量词** *+,++,?+,{n}+,{n,}+,{x,y}+
*  **文字（非元字符）范围** \Q...\E
*  **多选结构** |
*  **递归**
*  **条件判断**

### 二、preg函数

* **preg_match** 测试正则表达式能否在字符串中找到匹配，并提取数据
* **preg_match_all** 从字符串中提取数据
* **preg_replace** 在字符串的副本中替换匹配的文本
* **preg\_replace\_callback** 对字符串中的每处匹配文本调用处理函数
* **preg_split** 将字符串切分为子串数组
* **preg_grep** 选出数组中能/不能由表达式匹配的元素
* **preg_quote** 转义字符串中的正则表达式元字符

### 三、PHP单引号字符串
详细内容见：http://lyj1215.com/2017/09/20/string/

>因为正则表达式很有可能包含反斜线，如果使用单引号字符串文本，正则表达式就可以省略许多额外的转义。PHP的单引号字符串只有两个元序列。'\'','\\'
在正则表达式中使用\\匹配一个\,在单引号字符串中，\都应表示为\\,所以\\就成了\\\\,四个反斜线才能匹配一个反斜线。

>反斜线在单引号字符串和双引号字符串 中都有特殊含义，因此要匹配一个反斜线， 模式中必须写为 ”\\\\”。 译注： “/\\/”， 首先它作为字符串，反斜线会进行转义， 那么转义后的结果是/\/，这个才是正则表达式引擎拿到的模式， 而正则表达式引擎也认为 \ 是转义标记，它会将分隔符 / 进行转义， 从而得到的是一个错误，因此，需要 4 个反斜线才可以匹配一个反斜线。

```php
//以下例子 需要匹配abc\,写正则应该为abc\\,在代码中用单引号引起来应该是四个\
$re = '/abc\\\\/';
$str = 'abc\\';
preg_match_all($re, $str, $matches);
print_r($matches);

print_r('/^.*\/'); //   /^.*\/
print_r('/^.*\\/');//   /^.*\/
print_r('/^.*\\\/');//   /^.*\\/
print_r('/^.*\\\\/');//   /^.*\\/
```

### 四、递归的正则表达式
> 请先思考如何来匹配(1*(3+2))  嵌套括号的内容((()))这种  ，\(([^)]*)\)这个正则只能匹配 到(1*(3+2)，在以前, 这种情况, 正则无法处理, 最多只能处理固定层数的递归, 而无法处理无线递归的情况… 而在perl 5.6以后, 引入了一个新的特性: Recursive patterns, 使得这种需求可以被正确的处理.**(?R) ,这个表示正则模式本身(?R)的作用就是递归地替换它所在的整条正则表达式**

```php
#1(?R)*#
//我们来仔细看一下, 这个正则, 首先它匹配数字"1", 然后(?R)*表示, 正则式本身, 也就是说, 可以认为是:
#1(正则本身(正则本身).....)*#   或者#1(1(1(1)))# ,匹配一堆1
//于是, 对于文章开头说到的情况:"括号配对", 可以写下如下的正则式:
#\((?R)*\)#
```

>现在再来思考一下如何匹配(a(b(c)d)e) ,先剧透下正则应该是：'/\(([^()]+|(?R))*\)/'
>
>现在我们来思考一下为什么是这样写：
我们已经知道了(?R)的作用就是递归的替换他所在的整条正则表达式，在每次迭代的时候，PHP语法分析器都会将(?R)替换为"\(([^()]+|(?R))*\)" ,因此上面的正则表达式等价于：

>"\(([^()]+|\(([^()]+|\(([^()]+)*\))*\))*\))/"
>
>现在我们来分析下"\(([^()]+|(?R))*\)"是如何匹配 "(a(b(c)d)e)"的：

>"(c)"这部分被正则式 "\(([^()]+)*\)" 匹配. 请注意, (c) 其实就相当于整个递归的一个缩影, 麻雀虽小五脏俱全, 因此它用到了整个正则表达式. 换言之, 下一步中的(c), 可以使用(?R) 来匹配. 
>
>(b(c)d)的匹配过程为: 
>
>"\("匹配"("; 
>
>"[^()]+"匹配"b"; 
>
>(?R)匹配"(c)"; 
>
>"[^()]+"匹配"d"; 
>
>"\)"匹配")". 
>
>所有捕获子组最终被设置的捕获值都是从递归最外层子模式捕获的值。 如果上面的模式匹配 (a(b(c)d)e)，捕获子组最终被设置的值为 ”e”， 即顶级得到的最后一个值。 如果增加了额外的括号，\((((?>[^()]+)|(?R))*)\)，捕获到的字符串就是顶层括号的匹配内容 ”a(b(c)d)e”
