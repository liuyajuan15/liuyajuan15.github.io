{"meta":{"title":"lyjの博客","subtitle":"纸上得来终觉浅，绝知此事要躬行","description":"坚持就是胜利","author":"刘亚娟","url":"http://www/lyj1215.com"},"pages":[{"title":"关于我","date":"2017-09-08T06:55:40.000Z","updated":"2017-09-20T02:55:34.000Z","comments":true,"path":"about/index.html","permalink":"http://www/lyj1215.com/about/index.html","excerpt":"","text":"Email:liuyajuan15@qq.com Github:https://github.com/liuyajuan15 娟娟串珠 纸上得来终觉浅，绝知此事要躬行"},{"title":"categories","date":"2017-09-08T07:22:17.000Z","updated":"2017-09-08T07:22:17.000Z","comments":true,"path":"categories/index.html","permalink":"http://www/lyj1215.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2017-09-08T07:28:00.000Z","updated":"2017-09-08T07:40:58.000Z","comments":true,"path":"links/index.html","permalink":"http://www/lyj1215.com/links/index.html","excerpt":"","text":"晓铮大神: http://www.lxzfranky.com/ 广训大神: https://zhgxun.github.io"}],"posts":[{"title":"PHP字符串","slug":"string","date":"2017-09-20T08:28:52.000Z","updated":"2017-09-21T06:50:49.000Z","comments":true,"path":"2017/09/20/string/","link":"","permalink":"http://www/lyj1215.com/2017/09/20/string/","excerpt":"","text":"一个字符串 string 就是由一系列的字符组成，其中每个字符等同于一个字节。这意味着 PHP 只能支持 256 的字符集，因此不支持 Unicode 一个字符串可以用以下四种方式表达： 单引号 双引号 Heredoc 语法结构 Nowdoc 语法结构（自 PHP 5.3.0 起） 单引号 定义一个字符串的最简单的方法是用单引号把它包围起来(‘),当表达一个单引号自身，需要用反斜线()来转义，表达一个反斜线，需要两个反斜线。其他任何方式出现的反斜线都被会当成反斜线本身。单引号中的变量和除了转义(‘,)的其他特殊字符都不会被转义 1234567891011echo 'this is a simple string';// 可以录入多行echo 'You can also have embedded newlines in strings this way as it isokay to do';echo 'Arnold once said: \"I\\'ll be back\"'; // 输出： Arnold once said: \"I'll be back\" \\' 输出'echo 'You deleted C:\\\\*.*?'; // 输出： You deleted C:\\*.*?echo 'You deleted C:\\*.*?'; // 输出： You deleted C:\\*.*?echo 'This will not expand: \\n a newline'; // 输出： This will not expand: \\n a newline \\n不会被转义echo 'Variables do not $expand $either'; // 输出： Variables do not $expand $either 变量不会被解析 双引号 定义一个字符串还可以包围在双引号(“)中，双引号中PHP会对一些特殊的字符进行解析 \\n,\\r,\\t,\\v,\\e,\\f,\\,\\$,\\”,[0-7]{1,3},\\x[0-9A-Fa-f]{1,2} 双引号可以解析变量，除了前面的特殊字符其他字符的转义反斜线都会被显示出来 123456789101112&lt;?phpecho \"this is test\"; //this is testecho \"this is testtest \"; //this is test test echo \"Arnold once said: \\\"I'll be back\\\"\"; //Arnold once said: \"I'll be back\"echo \"You deleted C:\\\\*.*?\"; //You deleted C:\\*.*?echo \"You deleted C:\\*.*?\"; You deleted C:\\*.*?echo \"This will not expand: \\n a newline\"; //This will not expand: a newline$expand=\"one\";$either=\"two\";echo \"Variables do not $expand $either\"; //Variables do not one two heredoc &lt;&lt;&lt;EOT结构，注意结束标识符这行除了可能有一个分号外，绝对不能包含其他字符，不能缩进，不能有任何空白或制表符 Heredoc 就像是没有使用双引号的双引号字符串，变量可以解析，转义序列也可以使用，也可以用来初始化静态变量和类的属性和常量 123456$str = &lt;&lt;&lt;EODExample of stringspanning multiple linesusing heredoc syntax.EOD;// Nowdoc 类似于Heredoc,但是开始必须是&lt;&lt;&lt;’EOT’,标识符要用单引号引起来变量并不会被解析 12345$str = &lt;&lt;&lt;'EOD'Example of stringspanning multiple linesusing nowdoc syntax.EOD; 字符串转换为数值 当一个字符串被当做一个数值来取值。如果该字符串没有包含’.’,’e’,’E’ 并且其数字值在整型的范围之内，该字符串被当做整型来取值，其他所有情况下都被作为浮点数来取值。字符串的开始部分决定了它的值。 123456789&lt;?php$foo = 1 + \"10.5\"; // $foo is float (11.5)$foo = 1 + \"-1.3e3\"; // $foo is float (-1299)$foo = 1 + \"bob-1.3e3\"; // $foo is integer (1)$foo = 1 + \"bob3\"; // $foo is integer (1)$foo = 1 + \"10 Small Pigs\"; // $foo is integer (11)$foo = 4 + \"10.2 Little Piggies\"; // $foo is float (14.2)$foo = \"10.0 pigs \" + 1; // $foo is float (11)$foo = \"10.0 pigs \" + 1.0; // $foo is float (11) 转换成字符串 布尔型的TRUE被转换成‘1’，FALSE被转换成‘0’ 整型，浮点型 被转换成数字的字面样式的string 数组总是转换成字符串’Array’ 对象总是被转换成字符串 “Object” 资源 resource 总会被转变成 “Resource id #1” 这种结构的字符串 NULL总是被转变成空字符串 大部分的 PHP 值可以转变成 string 来永久保存，这被称作串行化，可以用函数 serialize() ，json_encode ()， var_export($items, true);都可以实现 字符串编码ASCII编码 我们知道，一个二进制位(Bit)有0、1两种状态，一个字节(Byte)有8个二进制位，有256种状态，每种状态对应一个符号，就是256个符号，从0000000到11111111。计算机诞生于美国，早期的计算机使用者大多使用英文，上世纪60年代，美国制定了一套英文字符与二进制位的对应关系，称为ASCII码，沿用至今 GB2312和GBK编码 等中国人们得到计算机时，已经没有可以利用的字节状态来表示汉字，况且有6000多个常用汉字需要保存呢。但是这难不倒智慧的中国人民，我们不客气 地把那些127号之后的奇异符号们直接取消掉, 规定：一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时，就表示一个汉字，前面的一个字节（他称之为高字节）从0xA1用到 0xF7，后面一个字节（低字节）从0xA1到0xFE，这样我们就可以组合出大约7000多个简体汉字了。在这些编码里，我们还把数学符号、罗马希腊的 字母、日文的假名们都编进去了，连在 ASCII 里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符，而原来在127号以下的那些就叫”半角”字符了。 中国人民看到这样很不错，于是就把这种汉字方案叫做 “GB2312“。GB2312 是对 ASCII 的中文扩展。 但是中国的汉字太多了，我们很快就就发现有许多人的人名没有办法在这里打出来，特别是某些很会麻烦别人的国家领导人。于是我们不得不继续把 GB2312 没有用到的码位找出来老实不客气地用上。 后来还是不够用，于是干脆不再要求低字节一定是127号之后的内码，只要第一个字节是大于127就固定表示这是一个汉字的开始，不管后面跟的是不是扩展字 符集里的内容。结果扩展之后的编码方案被称为 GBK 标准，GBK包括了GB2312 的所有内容，同时又增加了近20000个新的汉字（包括繁体字）和符号 Unicode（万国码，国际码，统一码） 随着计算机的流行，使用计算机的人越来越多，不仅限于美国，整个世界都在使用,因为当时各个国家都像中国这样搞出一套自己的编码标准，结果互相之间谁也不懂谁的编码，谁也不支持别人的编码。正在这时，大天使加百列及时出现了——一个叫 ISO （国际标谁化组织）的国际组织决定着手解决这个问题。他们采用的方法很简单：废了所有的地区性编码方案，重新搞一个包括了地球上所有文化、所有字母和符号 的编码！他们打算叫它”Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “unicode“。这就是Unicode编码（Unique Code），也称统一码、万国码。 UTF-8 和 Unicode的关系 Unicode是一种字符编码方法 实际传输过程中, 不同系统平台的设计不一定一致 不同的编码空间利用率不同 UTF-8是为了传输而设计 UTF-8是一种针对Unicode的可变长度字符编码 UTF-8是以8位为基本编码单位 注意的是unicode一个中文字符占2个字节，而UTF-8一个中 文字符占3个字节 GB2312和GBK编码 GB2312由中国国家标准总局发布 古汉语的罕用字和繁体字，GB2312不能处理 收录的汉字已经覆盖中国大陆99.75%的使用频率。 注意GB2312/GBK是定长编码（ascii字符占1个字节） GBK不是标准，它对罕见字，繁体字都支持 UTF8，GBK之间的转换与选择 GBK、GB2312等与UTF8之间都必须通过Unicode编码才能相互转换 优先选择UTF-8，对程序员有利 为了节省存储空间，选择GBK 考虑兼容其它系统，选择GBK 要给外国人看(韩国人)，就选 UTF-8 需要支持多语言，得选择UTF-8 字符串函数多字节转码函数 mbstring 和 iconv 优先选择mbstring 为了追求速度，可以用iconv mbstring功能更强大，考虑的编码类型更多 mbstring有55个函数，iconv只有11个 输入输出函数 echo —输出一个或多个字符串 print —输出字符串 vprintf —输出格式化字符串 printf —将格式化后的字符串写入到流 sprintf —返回格式化字符串 vsprintf —同sprintf，但是接收一个数组参数 sscanf —根据指定格式解析输入的字符 查找字符位置函数 strpos — 查找字符串首次出现的位置 stripos —不区分大小写 strrpos — 查找最后一次出现的位置 strripos —不区分大小写 字符串替换函数 str_replace — 子字符串替换 substr_replace — 替换字符串的子串 字符串分割和合并相关 explode — 使用一个字符串分割另一个字符串 implode — 将一个一维数组的值转化为字符串 join — 别名 implode str_getcsv — 解析 CSV 字符串为一个数组 str_split — 将字符串转换为数组 strtok — 标记分割字符串 chunk_split — 将字符串分割成小块 parse_str — 将字符串解析成多个变量 字符串去除空白字符 trim — 去除字符串首尾处的空白字符 ltrim — 删除字符串开头的空白字符 rtrim — 删除字符串末端的空白字符 HTML代码相关 nl2br — 换行转为 htmlentities —转化所有可能的html字符(编码) html_entity_decode htmlspecialchars — 转化html几个特有的字符 htmlspecialchars_decode 数据库相关 addslashes — 使用反斜线引用字符串 stripslashes — 反引用 addcslashes — 转义制定字符串中的字符 stripcslashes — 反引用 mysql_real_escape_string URL字符串函数 base64_decode — 对使用 base64 编码的数据进行解码 base64_encode — 使用 MIME base64 对数据进行编码 http_build_query — 生成 URL-encode 之后的请求字符串 parse_url — 解析 URL，返回其组成部分 rawurldecode — 对已编码的 URL 字符串进行解码 rawurlencode — 按照 RFC 1738 对 URL 进行编码 urldecode — 解码已编码的 URL 字符串 urlencode — 编码 URL 字符串 字符类型函数 ctype_alpha 是否字母 ，全部是才返回true，否则返回false ctype_lower 是否小写 ，全部是才返回true，否则返回false ctype_upper 是否大写 ，全部是才返回true，否则返回false ctype_digit 是否数字 ，全部是才返回true，否则返回false 字符串安全处理//过滤危险的HTML(默认级别) $str = preg_replace(\"#script:#i\", \"s c r i p t :\", $str); $str = preg_replace(\"#[\\/]{0,1}(link|meta|ifr|fra|src)[^&gt;]*#isU\", '', $str); $str = preg_replace(\"#[\\r\\n\\t]{1,}#\", '', $str); //完全禁止HTML并转换一些不安全字符串 $str = addslashes(htmlspecialchars(stripcslashes($str))); $str = preg_replace(\"#eval#i\", 'e v a l', $str); $str = preg_replace(\"#union#i\", 'u n i o n', $str); $str = preg_replace(\"#concat#i\", 'c o n c a t', $str); $str = preg_replace(\"#--#\", '- - ', $str); $str = preg_replace(\"#[\\r\\n\\r]{1,}#\", '', $str);","categories":[{"name":"PHP","slug":"PHP","permalink":"http://www/lyj1215.com/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://www/lyj1215.com/tags/PHP/"},{"name":"字符串","slug":"字符串","permalink":"http://www/lyj1215.com/tags/字符串/"}]},{"title":"烦人的钥匙串","slug":"busy","date":"2017-09-20T03:53:02.000Z","updated":"2017-09-20T04:44:49.000Z","comments":true,"path":"2017/09/20/busy/","link":"","permalink":"http://www/lyj1215.com/2017/09/20/busy/","excerpt":"","text":"之前的GitHub账号存在一些问题，因此注册了一个新的账号，来管理我的项目，可是当我注册完新账号后，一系列的问题就来了，整整折腾了一个上午 1.https://liuyajuan15.github.io 不能访问，提示not found ，可是项目明明已经存在了呀,后来在晓铮的帮助下选择了一个主题，果然就好了 2.由于我之前绑定了域名，因此换了新项目之后也要绑定域名，当我ping liuyajuan15.github.io的时候，才发现原来IP都是一样的，又涨了见识。 3.以上问题解决了之后当我在本地提交代码时，提交不能提交，原因是没有权限，账户名还是原来的juaner，先把git config 给改掉，查看之后没问题了，结果提交还是同样的错误，此处好悲伤，后来各种百度各种查资料，才发现原来是Mac的钥匙串导致的。 猛地想起来，Mac确实有这么一回事，赶紧搜索git，把之前的账号给删除，再次提交需要输入GitHub的账号密码，结果就这么好了。","categories":[{"name":"其他","slug":"其他","permalink":"http://www/lyj1215.com/categories/其他/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www/lyj1215.com/tags/git/"},{"name":"github","slug":"github","permalink":"http://www/lyj1215.com/tags/github/"},{"name":"mac","slug":"mac","permalink":"http://www/lyj1215.com/tags/mac/"}]},{"title":"php中的正则","slug":"regex5","date":"2017-09-19T06:26:49.000Z","updated":"2017-09-22T08:21:34.000Z","comments":true,"path":"2017/09/19/regex5/","link":"","permalink":"http://www/lyj1215.com/2017/09/19/regex5/","excerpt":"","text":"一、PHP的特性和流派详细内容见：http://lyj1215.com/2017/09/12/regex1/ 字符缩略表示法 \\a警报,\\b退格（在字符组内部支持，外部是单词分界符）,\\eEscape字符,\\f进制符,\\n,\\r,\\t, 字符组及相关结构 字符组[…][^…] 几乎任何字符 点号 字符组缩略表示法 \\w,\\d,\\s,\\W,\\D,\\S Unicode混合序列\\X ,只能与模式修饰符u连用 Unicode属性和区块\\p{Prop},\\P{Prop} ，可用于字符组内部，只能与模式修饰符u连用 锚点及其他零长度断言 行/字符串起始位置 ^ \\A 正常情况：^匹配字符串起始位置;增强型行锚点模式：^还可以匹配任何换行符之后的位置，\\A总是和^一样 行字符串结束位置 $ \\Z \\z 正常情况：$匹配字符串的结束位置，匹配字符串结尾的换行符；增强型行锚点模式：$匹配字符串的末尾，匹配任何换行符之前的位置。\\Z 总是和普通的$一样，\\z总是匹配字符串的末尾。 当前匹配的起始位置 \\G 单词分界符 \\b \\B 环视结构 (?=exp) (?!exp) (?&lt;=exp) (?&lt;!exp) 详细信息见：http://lyj1215.com/2017/09/12/regex4/ 注释及模式修饰符 表达式内部模式修饰符 (?i),允许出现的有 i,m,s ,x,U,X , 模式修饰范围（?i:） 注释 (?#…),只在模式修饰符x下有效 分组及捕获 捕获型括号(…) 反向引用 \\1 \\2 命名捕获 (?\\) 或者(?’name’) 反向引用 \\k\\或者 \\k ‘name’ 非捕获型 (?:exp) 让多个子组可以共用一个后向引用数字 (?|) 固化分组 匹配优先量词 *,+,?,{n},{n,},{x,y} 忽略优先量词 *?,+?,??,{n}?,{n,}?,{x,y}? 占有优先量词 *+,++,?+,{n}+,{n,}+,{x,y}+ 文字（非元字符）范围 \\Q…\\E 多选结构 | 递归 条件判断 二、preg函数 preg_match 测试正则表达式能否在字符串中找到匹配，并提取数据 preg_match_all 从字符串中提取数据 preg_replace 在字符串的副本中替换匹配的文本 preg_replace_callback 对字符串中的每处匹配文本调用处理函数 preg_split 将字符串切分为子串数组 preg_grep 选出数组中能/不能由表达式匹配的元素 preg_quote 转义字符串中的正则表达式元字符 三、PHP单引号字符串详细内容见：http://lyj1215.com/2017/09/20/string/ 因为正则表达式很有可能包含反斜线，如果使用单引号字符串文本，正则表达式就可以省略许多额外的转义。PHP的单引号字符串只有两个元序列。’\\’’,’\\‘在正则表达式中使用\\匹配一个\\,在单引号字符串中，\\都应表示为\\,所以\\就成了\\\\,四个反斜线才能匹配一个反斜线。 反斜线在单引号字符串和双引号字符串 中都有特殊含义，因此要匹配一个反斜线， 模式中必须写为 ”\\\\”。 译注： “/\\/”， 首先它作为字符串，反斜线会进行转义， 那么转义后的结果是/\\/，这个才是正则表达式引擎拿到的模式， 而正则表达式引擎也认为 \\ 是转义标记，它会将分隔符 / 进行转义， 从而得到的是一个错误，因此，需要 4 个反斜线才可以匹配一个反斜线。 12345678910//以下例子 需要匹配abc\\,写正则应该为abc\\\\,在代码中用单引号引起来应该是四个\\$re = '/abc\\\\\\\\/';$str = 'abc\\\\';preg_match_all($re, $str, $matches);print_r($matches);print_r('/^.*\\/'); // /^.*\\/print_r('/^.*\\\\/');// /^.*\\/print_r('/^.*\\\\\\/');// /^.*\\\\/print_r('/^.*\\\\\\\\/');// /^.*\\\\/ 四、递归的正则表达式 请先思考如何来匹配(1(3+2)) 嵌套括号的内容((()))这种 ，(([^)]))这个正则只能匹配 到(1(3+2)，在以前, 这种情况, 正则无法处理, 最多只能处理固定层数的递归, 而无法处理无线递归的情况… 而在perl 5.6以后, 引入了一个新的特性: Recursive patterns, 使得这种需求可以被正确的处理.*(?R) ,这个表示正则模式本身(?R)的作用就是递归地替换它所在的整条正则表达式 12345#1(?R)*#//我们来仔细看一下, 这个正则, 首先它匹配数字\"1\", 然后(?R)*表示, 正则式本身, 也就是说, 可以认为是:#1(正则本身(正则本身).....)*# 或者#1(1(1(1)))# ,匹配一堆1//于是, 对于文章开头说到的情况:\"括号配对\", 可以写下如下的正则式:#\\((?R)*\\)# 现在再来思考一下如何匹配(a(b(c)d)e) ,先剧透下正则应该是：’/(([^()]+|(?R))*)/‘ 现在我们来思考一下为什么是这样写：我们已经知道了(?R)的作用就是递归的替换他所在的整条正则表达式，在每次迭代的时候，PHP语法分析器都会将(?R)替换为”(([^()]+|(?R))*)“ ,因此上面的正则表达式等价于： “(([^()]+|(([^()]+|(([^()]+)))))*))/“ 现在我们来分析下”(([^()]+|(?R))*)“是如何匹配 “(a(b(c)d)e)”的： “(c)”这部分被正则式 “(([^()]+)*)“ 匹配. 请注意, (c) 其实就相当于整个递归的一个缩影, 麻雀虽小五脏俱全, 因此它用到了整个正则表达式. 换言之, 下一步中的(c), 可以使用(?R) 来匹配. (b(c)d)的匹配过程为: “(“匹配”(“; “[^()]+”匹配”b”; (?R)匹配”(c)”; “[^()]+”匹配”d”; “)“匹配”)”. 所有捕获子组最终被设置的捕获值都是从递归最外层子模式捕获的值。 如果上面的模式匹配 (a(b(c)d)e)，捕获子组最终被设置的值为 ”e”， 即顶级得到的最后一个值。 如果增加了额外的括号，((((?&gt;[^()]+)|(?R))*))，捕获到的字符串就是顶层括号的匹配内容 ”a(b(c)d)e”","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www/lyj1215.com/categories/正则表达式/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www/lyj1215.com/tags/正则表达式/"},{"name":"PHP","slug":"PHP","permalink":"http://www/lyj1215.com/tags/PHP/"}]},{"title":"正则表达式高级应用","slug":"regex4","date":"2017-09-18T02:34:54.000Z","updated":"2017-09-20T10:17:21.000Z","comments":true,"path":"2017/09/18/regex4/","link":"","permalink":"http://www/lyj1215.com/2017/09/18/regex4/","excerpt":"","text":"一、环视（断言、零宽断言） 以下内容参考《精通正则表达式》和Zjmainstay学习笔记 相关教程环视，在不同的地方又称之为零宽断言，简称断言。 环视强调的是它所在的位置，前面或者后面，必须满足环视表达式中的匹配情况，才能匹配成功。 环视可以认为是虚拟加入到它所在位置的附加判断条件，并不消耗正则的匹配字符。 环视部分是不占宽度的，所以有零宽断言的叫法，所谓不占宽度就是：环视的匹配结果不纳入数据结果，环视它匹配过的地方，下次还能用它继续匹配 用一句通俗的话解释： 环视，就是先从全局环顾一遍正则，（然后断定结果，）再做进一步匹配处理。 断言，就是先从全局环顾一遍正则，然后断定结果，再做进一步匹配处理。 1.环视的类型 肯定顺序(?=exp) 匹配后面是exp的数据 a(?=b) 匹配后面是b的数据，即ab匹配，ac不匹配 ，匹配出来的结果是a 否定顺序(?!=exp) 匹配后面不是exp的数据 a(?!=b) 匹配后面不是b的数据，即ab不匹配，ac,ad,ae 等可以匹配，匹配出来的结果是a 肯定逆序(?&lt;=exp) 匹配前面是exp的数据 (?&lt;b)a 匹配前面是b的数据，即ba匹配，ca不匹配，匹配出来的结果是a 否定逆序(?&lt;!exp) 匹配前面不是exp的数据 (?&lt;!b)a 匹配前面不是b的数据，即ba不匹配，ca,da 等可以匹配，匹配出来的结果是a以上四个例子匹配出来的结果都是a,是因为环视强调的是它所在的位置，环视的匹配结果是不纳入数据结果的 2.简单环视过程例如，对于源字符串ABC，正则(?=A)[A-Z]匹配的是:1). (?=A)所在的位置，后面必须是A,下图红色虚线位置所示2). 表达式[A-Z]匹配A-Z中任意一个字母根据两个的先后位置关系，组合在一起，那就是：(?=A)所在的位置，后面是A，而且是A-Z中任意一个字母，因此，上面正则表达式匹配一个大写字母A。从例子可以看出，从左到右，正则分别匹配了环视(?=A)和[A-Z]，由于环视不消耗正则的匹配字符，因此，[A-Z]还能对A进行匹配，并得到结果。 3.什么是消耗正则的匹配字符？ 文章开头提到正则的环视是不消耗正则的匹配字符，那么什么是消耗正则的匹配字符呢? 正则是按单个字符匹配的，从左到右逐个匹配源字符串中的内容。 1).一次匹配消耗匹配字符匹配过程 a. 正则A：因为没有位置限定，因此是从源字符串开始位置开始，也就是正则里的^，这个^是虚拟字符，表示匹配字符串开始位置，也就是源字符串ABCAD里的A前面的位置，因为正则A能够匹配源字符串A，匹配成功，匹配位置从源字符串^的位置后移一位，到达A后面，即此时源字符串ABCAD的A这个字符已经被消耗，接下来的正则匹配从A后面开始。 b. 正则[A-Z]：当前匹配位置为第一个A字母后面位置，正则[A-Z]对源字符串ABCAD里的B字母进行匹配，匹配成功，位置后移到B字母后面的位置。至此，由于正则已经匹配完成，因此，正则A[A-Z]匹配结果是AB。 我们知道，有些语言支持g模式修饰符，也就是全局匹配，那么，上面例子中，正则匹配1次成功之后，将会从匹配成功位置（B字母后面位置）开始，再从头进行匹配一次正则，直到源字符串全部消耗完为止。 2).多次匹配消耗匹配字符匹配过程 因此，全局匹配的过程补充如下： c. 正则A：当前匹配位置为B字母后面位置，正则A去匹配源字符串中的C，匹配失败，匹配位置后移一位，此时C被消耗了。 d. 正则A：当前匹配位置为C字母后面位置，正则A去匹配源字符串中的第二个A字母，匹配成功，匹配位置后移一位，此时A被消耗了。 e. 正则[A-Z]：当前匹配位置为第二个A字母后面位置，正则[A-Z]对源字符串ABCAD里的D字母进行匹配，匹配成功，位置后移到D字母后面的位置，此时D被消耗了。 f. 由于正则里还有个源字符串结束位置，也就是正则里的$，这个$也是虚拟字符，因此，还要继续进行匹配： 正则A：当前匹配位置为D字母后面的位置，正则A去匹配源字符串的结束位置，匹配失败，匹配结束。 最终匹配结果是AB和AD。 3).不消耗匹配字符 需求：字母、数字组合，不区分大小写，不能纯数字或者纯字母，6-16个字符。 通用正则：^[a-z0-9]{6,16}$ 字母数字组合，6-16个字符 排除纯字母：(?!^[a-z]+$) 排除纯数字：(?!^[0-9]+$) 组合起来：(?!^[a-z]+$)(?!^[0-9]+$)^[a-z0-9]{6,16}$","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www/lyj1215.com/categories/正则表达式/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www/lyj1215.com/tags/正则表达式/"}]},{"title":"正则表达式的匹配原理","slug":"regex3","date":"2017-09-17T05:44:41.000Z","updated":"2017-09-20T09:57:00.000Z","comments":true,"path":"2017/09/17/regex3/","link":"","permalink":"http://www/lyj1215.com/2017/09/17/regex3/","excerpt":"","text":"之所以会了解匹配原理，是因为之前也听过正则的引擎分为很多种，也听过NFA,DFA,但是究其根本还是模棱两可，因此仔细阅读《精通正则表达式》的第四章，对其关键点进行整理。 一、正则引擎的分类 二、匹配的基础 三、DFA,NFA 四、回溯 五、总结 一、正则引擎的分类部分程序及其所使用的引擎 二、匹配的基础三、DFA,NFADFA:文本主导，速度快，最长的左子正则式优先匹配成功NFA:表达式主导，支持忽略优先量词，捕获型括号，回溯，最左子正则式优先匹配成功 四、回溯五、总结","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www/lyj1215.com/categories/正则表达式/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www/lyj1215.com/tags/正则表达式/"}]},{"title":"正则表达式测试题","slug":"regex2","date":"2017-09-13T02:28:41.000Z","updated":"2017-09-20T09:38:49.000Z","comments":true,"path":"2017/09/13/regex2/","link":"","permalink":"http://www/lyj1215.com/2017/09/13/regex2/","excerpt":"","text":"正则掌握程度测试题,以下测试题来自于 https://www.zybuluo.com/Zjmainstay/note/709093， 答案是我自己的分析，欢迎各位进行批评与指导,部分习题答案后续不上 一.分组提取/非捕获组 二.单字符或 三.多字符或 四.分组引用 五.匹配换行数据 六.存在（或） 七. 存在（与） 八. 特殊限制（环视否定） 九. 替换分组使用 十. 分组可选 十一. 单字符拆分（数字） 十二. 贪婪模式 十三. 非贪婪模式 十四. 占用模式(PCRE) 十五. |字符分界（|的作用域） 十六. 元字符转义 十七. 分隔符绕过（PCRE） 十八. 匹配溢出排除 十九. 环视循环提取格式化 二十. 三段论应用 一. 分组提取/非捕获组 分组，是正则里一个非常重要的概念，我们需要针对某个区域提取数据，往往需要依赖分组。而分组，其实就是正则里()括住的部分。 分组提取 123456需求：在分组1中匹配meta中author属性的值源串： &lt;meta author=\"Zjmainstay\" /&gt; another author=\"Zjmainstay too\"预期：分组1得到Zjmainstay正则：'/&lt;meta[^&gt;]author=\"(.*?)\".*?\\/&gt;/' 非捕获组 针对上面的分组，有时候，我们并不需要捕获某个分组的内容，我们可以使用非捕获组(?:表达式)，从而不捕获表达式部分内容到分组中。 1234567源串：aababcabcd预期：匹配得到 ab 和 abcd，不包含分组1正则： '/^(?:\\w\\w)+$/m' 二. 单字符或 或条件是正则使用过程中常用的概念，比如，密码由字母或数字组成，这里就用到了或条件，而且，由于字母或数字都是单个字符，因此，可以使用[a-z0-9]这样的单字符或语法实现。 常犯错误：匹配a或b写成[a|b]，此表达式实际上表示a或b或|，在[]内部的|表示其本身，注意区分(a|b)表示a或b的写法。 123456789101112需求：匹配由 A/S/D/F 4个字母(区分大小写)组成的长度为3字符串源串：ABCASDADSASFBBCA|SA|DASDF预期：以[]元字符获得3个字母的或集，匹配 ASD/ADS/ASF 3组数据正则：'/\\b[ASDF]&#123;3&#125;\\b/m' 三. 多字符或 相对单字符或条件，多字符或也是很常见的，比如，我们需要匹配http或ftp两个协议头的url，就需要^(http|ftp)://.+$这样的语法来实现。 123456789101112需求：匹配每行数据中以.jpg/.jpeg/.png/.gif结尾的图片名称（含后缀）源串：image.jpgimage.jpegimage.pngimage.gifnot_image.txtnot_image.docnot_image.xlsnot_image.ppt预期：匹配 image.jpg/image.jpeg/image.png/image.gif 4个结果正则：'/.*?\\.(jpg|jpeg|png|gif)/m' 四. 分组引用 前面介绍了分组，那某个分组在我们匹配过程中重复出现，又该如何处理？分组引用恰恰解决这个问题。比如，匹配出现重复单词的一行数据，我们可以这么写（多行模式）：/^.?(\\b\\S+\\b).?\\1.*$/m，\\1表示引用前面分组1中匹配到的内容，也就是重复的单词内容。 12345678需求：匹配连续相同3次的数字源串：111121112222预期：匹配 111/222 两组数据正则：'/(\\d)\\1\\1/m' 五. 匹配换行数据 “我的正则本来好好的，突然不行了！”这个是很多正则新人遇到的问题，而这个问题，很多时候，就是因为原来正则中的.不能匹配新数据里的换行导致的。这时候，只需要把.改成[\\s\\S]这样的表达式就可以了。这个表达式表示空格或非空格，也就是任意字符啦。 12345678需求：分别使用单行模式和普通模式匹配id=\"author\"的div中数据，div标签不在同一行源串：&lt;div id=\"author\"&gt;Zjmainstay&lt;/div&gt;预期：Zjmainstay正则1：'@&lt;div[^&gt;]id=\"author\"&gt;(.*?)&lt;/div&gt;@ms'正则2： 六. 存在（或） 匹配多种或条件的数据，没有特殊限制 1234567891011121314需求：匹配每行中包含“作者”或者“读者”的数据源串：本文的作者是Zjmainstay本文有很多读者读者可以是任何一个地方的人这里的任何一个地方说明读者也能在国外什么乱七八糟的推理你不匹配我，凭什么要我推荐你的博客 www.zjmainstay.cn预期：匹配本文的作者是Zjmainstay本文有很多读者读者可以是任何一个地方的人这里的任何一个地方说明读者也能在国外正则：$re = '/^.*?(作者|读者).*?$/m' 匹配多种或条件的数据，有特殊限制（不使用环视） 123456789需求：匹配每行中“读者”在开头或结尾的数据源串：本文作者是Zjmainstay，有很多读者读者可以是任何一个地方的人这里的任何一个地方说明读者也能在国外预期：匹配本文作者是Zjmainstay，有很多读者读者可以是任何一个地方的人正则： 匹配多种或条件的数据，有特殊限制（使用环视） 123456789需求：匹配每行中“读者”在开头或结尾的数据源串：本文作者是Zjmainstay，有很多读者读者可以是任何一个地方的人这里的任何一个地方说明读者也能在国外预期：匹配本文作者是Zjmainstay，有很多读者读者可以是任何一个地方的人正则： 七. 存在（与）校验密码必须包含字母、数字和特殊字符，6-16位 12345678910111213141516171819202122需求：校验密码必须包含字母、数字和特殊字符，6-16位，假定特殊字符为 -_= 三个字符源串：12345123456123456123456123412345612345612345a1234a12345-1234-12345a-123a-1234a-1234a-1234a-12a-1234a-1234a-1234aaaaaaaaaaa-_=-_-_=-_=预期：匹配a-1234a-1234a-1234a-12正则： 八. 特殊限制（环视否定） 使用\\d{1,3}匹配1-999的数据，不能以0开头 123456789101112131415需求：使用\\d&#123;1,3&#125;匹配每行中1-999的数据，不能以0开头源串：110100999100001001预期：匹配110100999正则：'/(?!0)(?&lt;!\\d)\\d&#123;1,3&#125;\\b/' 匹配除了span标签外的所有标签 1234567891011需求：匹配除了&lt;span&gt;内容&lt;/span&gt;标签外的所有&lt;tagName&gt;内容&lt;/tagName&gt;格式标签源串：&lt;div&gt;匹配我&lt;/div&gt;&lt;span&gt;不匹配我&lt;/span&gt;&lt;p&gt;匹配我&lt;/p&gt;&lt;i&gt;匹配我&lt;/i&gt;预期：匹配&lt;div&gt;匹配我&lt;/div&gt;&lt;p&gt;匹配我&lt;/p&gt;&lt;i&gt;匹配我&lt;/i&gt;正则： 九. 替换分组使用 给源串每个链接加上http://www.zjmainstay.cn前缀 123456789101112131415需求：给源串每个链接加上http://www.zjmainstay.cn前缀源串：&lt;a id=\"link-1\" href=\"/regexp-one\"&gt;正则文章合集（All In One)&lt;/a&gt;&lt;a id=\"link-2\" href=\"/my-regexp\"&gt;正则入门教程&lt;/a&gt;&lt;a id=\"link-3\" href=\"/deep-regexp\"&gt;正则高级教程&lt;/a&gt;&lt;a id=\"link-4\" href=\"/regexp-lookaround\"&gt;正则环视详解&lt;/a&gt;&lt;a id=\"link-5\" href=\"/php-curl\"&gt;PHP cURL应用&lt;/a&gt;预期：替换得到&lt;a id=\"link-1\" href=\"http://www.zjmainstay.cn/regexp-one\"&gt;正则文章合集（All In One)&lt;/a&gt;&lt;a id=\"link-2\" href=\"http://www.zjmainstay.cn/my-regexp\"&gt;正则入门教程&lt;/a&gt;&lt;a id=\"link-3\" href=\"http://www.zjmainstay.cn/deep-regexp\"&gt;正则高级教程&lt;/a&gt;&lt;a id=\"link-4\" href=\"http://www.zjmainstay.cn/regexp-lookaround\"&gt;正则环视详解&lt;/a&gt;&lt;a id=\"link-5\" href=\"http://www.zjmainstay.cn/php-curl\"&gt;PHP cURL应用&lt;/a&gt;查找：替换： 将每行数据格式化为一条SQL语句 1234567891011需求：将每行特定格式数据格式化为SQL语句源串：1 2017-04-11 Zjmainstay2 2017-04-12 Nobody3 2017-04-13 Somebody预期：替换得到INSERT INTO table_log(`id`, `created_at`, `author`) values('1', '2017-04-11', 'Zjmainstay');INSERT INTO table_log(`id`, `created_at`, `author`) values('2', '2017-04-12', 'Nobody');INSERT INTO table_log(`id`, `created_at`, `author`) values('3', '2017-04-13', 'Somebody');查找：替换： 十. 分组可选 分组可选 123456789101112需求：判断如果单词以A开头，匹配Apple；如果单词以B开头，匹配Banana；否则匹配Empty源串：AngleAppleBananaBestEmpty预期：匹配AppleBananaEmpty正则： 分组可选与分组引用 123456789需求：匹配html标签的属性值，属性值可以由双引号、单引号、无单双引号定界源串：&lt;div id=\"I'm Zjmainstay\" class=\"name\" data-year=2017 age='27'&gt;预期：分组匹配I'm Zjmainstayauthor201727正则： 十一. 单字符拆分（数字）匹配0.00-100.00的数值，可以有0-2位小数 1234567891011121314151617181920212223242526需求：匹配0.00-100.00的数值，可以有0-2位小数，不能以小数点结尾，不能以2个以上的0开头思路：(100|10-99|0-9) + 0-2小数位 + 排除小数点结尾、2个以上0开头的情况源串：010.00.009.0018.0027.036.0045.0054.0063.0072.0081.0090.0099.99100.000.001100.01100.001101预期：匹配0.00~100.00正则： 十二. 贪婪模式 匹配链接中的文件名 12345678需求：利用贪婪模式，分组1得到每行链接中的文件名源串：http://localhost.com/a/b/c/d/file1.txthttps://localhost.com/a/b/file2long.jpg预期：分组0匹配行数据，分组1匹配文件名file1.txtfile2long.jpg正则： 限定字符贪婪优化匹配性能 12345需求：匹配div id=\"author\"的标签内容源串：&lt;div id=\"author\" class=\"author-text something-useless\"&gt;Zjmainstay&lt;/div&gt;预期：利用贪婪模式去掉div中的噪点（无关数据），分组1匹配到Zjmainstay正则： 十三. 非贪婪模式 贪婪模式，正则会优先尽可能少地匹配能匹配到的内容。当剩余正则匹配剩余部分字符（源串）但无法满足匹配时，非贪婪部分继续匹配更多内容，尝试满足剩余部分字符的匹配。 匹配p标签内容 123456需求：匹配p标签内容源串：&lt;p&gt;内容1&lt;/p&gt;&lt;p&gt;内容2&lt;/p&gt;预期：在分组1中匹配到内容1和内容2正则： 十四. 占用模式(PCRE) 贪婪模式后再加一个+量词，如.++，效果是贪婪而且不回溯。 暂时没有想到应用场景。 十五. |字符分界（|的作用域） |作为或条件分隔符，它的分隔区间常常存在误用。在使用|字符的过程中，我们常常需要结合()来对它进行限定。如，^([0-9]+|[a-z]+)$表示纯数字或纯字母，如果没有()，那它又是另一种意思了。^[0-9]+|[a-z]+$等价于^[0-9]+或[a-z]+$，因此，它表示数字开头或者字母结尾，跟我们的需求有了很大的差别。 |字符分界 12345678需求：在分组1中匹配css或script的链接源串：&lt;script src=\"main.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"main.css\"&gt;预期：main.min.jsmain.css正则： 十六. 元字符转义 元字符，指正则中有特殊意义的字符，如.表示匹配除了换行符以外的任意字符，这个.就是元字符。在正则书写过程中，如果我们真的要匹配这个.，就需要对它进行转义，而不是让它使用正则的含义，比如，匹配域名里的.，我们就要写成/zjmainstay.cn/这样的正则。 元字符转义 123456789101112需求：表达式格式固定，提取其中的数值源串：(20+170)-5*1/5=?预期：A:20B:170C:5D:1E:5F:?正则：替换： 十七. 分隔符绕过（PCRE） 有时候，如果该语言支持多种分隔符，在写正则的过程中通常会通过规避分隔符的方式，减少对分隔符的转义，让正则看起来更清晰，写起来更舒服，当然，js中是不支持的。 分隔符绕过 123456需求：在不对/转义的情况下匹配p标签内容源串：&lt;p&gt;内容1&lt;/p&gt;&lt;p&gt;内容2&lt;/p&gt;预期：在分组1中匹配到内容1和内容2正则： 十八. 匹配溢出排除 匹配溢出，这不是一个术语名词，是我自己的叫法，主要指正则匹配内容超出了我们预期，导致匹配得到非预期的结果。 div标签匹配溢出 1234567需求：匹配内容为数字的div源串：&lt;div class=\"aaa bbb\"&gt;ABC&lt;/div&gt;&lt;div class=\"bbb ccc\"&gt;123&lt;/div&gt;预期：&lt;div&gt;123&lt;/div&gt;错误正则：/&lt;div.*?&gt;\\d+&lt;\\/div&gt;/正则： 多字符排除 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556需求：匹配不包含某个单词或词语的内容源串：http://www.zjmainstay.cnhttp://www.baidu.comhttp://www.qq.com预期：http://www.zjmainstay.cnhttp://www.qq.com正则：需求：匹配不包含某个单词或词语的内容源串：A(\"Excalibur\", \"誓约胜利之剑\", LONG_SWORD, (SPFX_NOGEN | SPFX_RESTR | SPFX_SEEK | SPFX_DEFN | SPFX_INTEL | SPFX_SEARCH), 0, 0, PHYS(5, 10), DRLI(0, 0), NO_CARY, 0, A_LAWFUL, PM_KNIGHT, NON_PM, 4000L, NO_COLOR);/* * Stormbringer only has a 2 because it can drain a level, * providing 8 more. */A(\"Stormbringer\", \"兴风者\", RUNESWORD, (SPFX_RESTR | SPFX_ATTK | SPFX_DEFN | SPFX_INTEL | SPFX_DRLI), 0, 0, DRLI(5, 2), DRLI(0, 0), NO_CARY, 0, A_CHAOTIC, NON_PM, NON_PM, 8000L, NO_COLOR);/* * Mjollnir will return to the hand of the wielder when thrown * if the wielder is a Valkyrie wearing Gauntlets of Power. */A(\"Mjollnir\", \"雷神之锤\", WAR_HAMMER, /* Mjo:llnir */ (SPFX_RESTR | SPFX_ATTK), 0, 0, ELEC(5, 24), NO_DFNS, NO_CARY, 0, A_NEUTRAL, PM_VALKYRIE, NON_PM, 4000L, NO_COLOR);A(\"Cleaver\", \"撕裂者\", BATTLE_AXE, SPFX_RESTR, 0, 0, PHYS(3, 6), NO_DFNS, NO_CARY, 0, A_NEUTRAL, PM_BARBARIAN, NON_PM, 1500L, NO_COLOR);/* * Grimtooth glows in warning when elves are present, but its * damage bonus applies to all targets rather than just elves * (handled as special case in spec_dbon()). */A(\"Grimtooth\", \"邪兽之牙\", ORCISH_DAGGER, (SPFX_RESTR | SPFX_WARN | SPFX_DFLAG2), 0, M2_ELF, PHYS(2, 6), NO_DFNS, NO_CARY, 0, A_CHAOTIC, NON_PM, PM_ORC, 300L, CLR_RED);/* * Orcrist and Sting have same alignment as elves. * * The combination of SPFX_WARN+SPFX_DFLAG2+M2_value will trigger * EWarn_of_mon for all monsters that have the M2_value flag. * Sting and Orcrist will warn of M2_ORC monsters. */A(\"Orcrist\", \"杀兽剑\", ELVEN_BROADSWORD, (SPFX_WARN | SPFX_DFLAG2), 0, M2_ORC, PHYS(5, 0), NO_DFNS, NO_CARY, 0, A_CHAOTIC, NON_PM, PM_ELF, 2000L, CLR_BRIGHT_BLUE); /* bright blue is actually light blue */预期：Excalibur=誓约胜利之剑Stormbringer=兴风者Mjollnir=雷神之锤Cleaver=撕裂者Grimtooth=邪兽之牙Orcrist=杀兽剑查找：替换： 十九. 环视循环提取格式化 在数据处理过程中，经常遇到一些格式化处理，比如简单地将一批数据格式化为SQL（参考9.2），还有复杂的需要对一行数据的某部分进行循环提取，然后格式化为特定格式。 12345678910111213141516需求：循环提取每行数据的分支部分和固定部分，格式化为特定格式源串：BBB|CCC|DDD=AAAFFF|GGG|HHH|III|JJJ|KKK=EEE预期：BBB=AAACCC=AAADDD=AAAFFF=EEEGGG=EEEHHH=EEEIII=EEEJJJ=EEEKKK=EEE查找：\\|(?=.*(=.*))替换：$1\\n 二十. 三段论应用 三段论:定锚点，去噪点，取数据。 锚点，在正则中指^、$、\\b这类零宽的位置，这里做了衍生，指能够唯一确定我们目标数据位置的参照点，比如author=lalala，我们要匹配author属性的数据，则author=就是我们的参照点，通过它，我们能快速写出提取author属性的数据的正则：author=(.+)。 噪点，就是对我们提取数据产生干扰的无关数据，我们在做正则匹配提取数据的过程中，可以选择性的忽略它们。当然，这里的忽略不是指不需要对它们做匹配，而是不需要对它们做精确匹配。 数据，这个当然是指我们需要提取的内容了，如上面锚点举例，我们通过author=(.+)的(.+)对lalala部分数据进行了提取，因此，匹配结果的分组1（程序语言中的数组下标1）中，就能得到我们的结果。而对于多个数据的提取，如噪点举例，我们只需要针对数据部分进行多个分组（括号）的提取即可。 分组的计数，一般可以数左括号，排除环视和非捕获组的左括号，从1开始，依次加1递增，1,2,3,4….n，不同语言最大分组个数不同，大家在使用过程中自行留意，不过一般用不了那么多分组。 理解了三段论的概念，我们在写正则的过程中，只需要将源串进行分割划分，根据目标数据确定锚点，过滤噪点，提取数据，就能得到我们想要的正则了。","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www/lyj1215.com/categories/正则表达式/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www/lyj1215.com/tags/正则表达式/"}]},{"title":"正则表达式基本介绍","slug":"regex1","date":"2017-09-12T07:41:25.000Z","updated":"2017-09-21T09:32:59.000Z","comments":true,"path":"2017/09/12/regex1/","link":"","permalink":"http://www/lyj1215.com/2017/09/12/regex1/","excerpt":"","text":"认识了解正则表达式也有几年了，每次要用时就百度下如何使用，对于转义到底该用几个’\\’总是弄不清楚，因此想抽出一大块时间来做这件事，彻彻底底的来了解正则，以下内容参考《PHP手册》和《精通正则表达式》和Zjmainstay学习笔记 相关教程 一、元字符：一、匹配位置的元字符 ，匹配的是一个位置，而非文本 脱字符 ^ : 表示匹配行首的文本 美元符号$ : 表示匹配行尾的文本 单词分界符 : \\b匹配单词的开始或者结束 \\B : 匹配不是单词开头或结束的位置 二、匹配计数功能的元字符 : 匹配0次到多次 *匹配优先量词，匹配尽可能多的内容* : 匹配一次到多次，最少匹配1次 *匹配优先量词，匹配尽可能多的内容* ？: 匹配0次或者1次 *匹配优先量词，匹配尽可能多的内容* {min,max} : 匹配min次到max次 *匹配优先量词，匹配尽可能多的内容* {min,} : 最少匹配min次 ?,+?,??,{min,max}? *忽略优先量词，匹配尽可能少的内容，跟非贪婪模式有关 +,++,?+,{min,max}+ *占有优先量词，类似普通匹配优先，一旦匹配某些内容，就不会交还，类似固化分组 三、匹配单个字符的元字符 [] : 字符组，匹配若干字符之一,匹配被中括号括起来的其中一个，相当于或。 例如gr[ea]y 匹配grey或者gray [^x] : 排除型字符组 匹配一个不等于X的字符，“匹配一个未列出的字符”，而不是”不要匹配列出的字符” . : 匹配单个任意字符 \\char : 转义字符 \\w : 匹配字母或数字或下划线或汉字 \\s : 匹配任意的空白符 \\d : 匹配数字 \\W : 匹配任意不是字母，数字，下划线，汉字的字符 \\S : 匹配任意不是空白符的字符 \\D : 匹配任意非数字的字符 四、其他元字符 | : 匹配任意分隔的表达式，php|java|linux 匹配php或java或者linux ,[]中如果是单个字符，直接写即可，如果是多个字符，则需要用|分开 () : 一是限定多选结构的范围，而是为反向引用捕获文本 \\1,\\2 : 反向引用 匹配之前的第一组，第二组括号捕获的文本 五、对以上个别元字符的详细解析： 脱字符^ ,有两个作用，一个是表示匹配行首的文本，另外一个是排除，在[]里面的是排除的意思，不在[]里面的是匹配行首的意思 字符组[],H[1-6]等同于H[123456],连字符-只有在[]内才为元字符，在外面为-本意 转义字符\\char ，一个特殊字符前面加上\\表示转义，特殊字符包括：()[]{}.*+?|\\^$/ () 括号有多个意思，详细内容见以下的分组捕获，当作用为限定多选结构的范围时，需要和[]进行区分 (Fri|1)st 匹配first 或1st ，但是Fri|1st就是匹配 Fri或1st 二、模式修饰符： PHP模式修饰符又叫模式修正符，是在正则表达式的定界符之外使用。主要用来调整正则表达式的解释，提扩展了正则表达式在匹配、替换等操作的某些功能，增强了正则的能力。 i 不区分大小写，(?i) 如果设置了这个修饰符，’a’和’A’是一样的。 s 单行模式，(?s)如果设定了这个修正符，那么，被匹配的字符串将视为一行来看，包括换行符，换行符将被视为普通字符串。 m 多行匹配模式，(?m)将字符串视为多行。默认的正则开始“^”和结束“$”将目标字条串作为一单一的一“行”字符（甚至其中包括换行符也是如此）。如果在修饰符中加上“m”，那么开始和结束将会指点字符串的每一行的开头就是“^”结束就是“$”。 x 忽略空白，(?x)正则表达式中的“空白字符”和“换行符”将会被忽略，除非它已经被转义，同时#号（#）被解释为注释的开头 e 只用在preg_replace()函数中，在替换字符串中逆向引用做正常的替换，将其(即“替换字符串”)作为PHP代码求值，并用其结果来替换所搜索的字符串。 A 如果使用这个修饰符，那么表达式必须是匹配的字符串中的开头部分。比如说”/a/A”匹配”abcd”。 D 模式中的$字符权匹配目标字符的结尾。没有此选项时，如果最后一个字符是换行符的话，美元符号也会匹配此字符之前。如果设定了修正符m则忽略此项。 E 与”m”相反，如果使用这个修饰符，那么”$”将匹配绝对字符串的结尾，而不是换行符前面，默认就打开了这个模式。 U 设置贪婪模式，(?U)和问号的作用差不多，最大限度的匹配就是贪婪模式。 贪婪模式会有一篇单独的笔记来记录 123456789101112131415161718192021222324252627//不区分大小写 i$s = \"First line Second LINE\";preg_match_all(\"/line/i\",$s,$m);print_r($m); //Array ( [0] =&gt; Array ( [0] =&gt; line [1] =&gt; LINE ) )//多行匹配模式 m$s = \"First line\\nSecond line\";preg_match_all(\"/^\\w/m\",$s,$m);print_r($m);//Array ( [0] =&gt; Array ( [0] =&gt; F [1] =&gt; S ) )//单行匹配模式 s$s = \"First line\\nSecond line\";preg_match_all(\"/^\\w/s\",$s,$m);print_r($m); //Array ( [0] =&gt; Array ( [0] =&gt; F ) )//忽略正则表达式中的“非转义的空白字符”和“回车换号符”$p = \"abc #category code\\n123 #item number\";$s = \"abc123\";preg_match_all(\"/\".$p.\"/x\",$s,$m);var_dump($m); //abc123，相当于匹配abc123//必须是字符串中的开头部分A$s = \"abcba\";preg_match_all(\"/a/A\",$s,$m); //a$s = \"abcba\";preg_match_all(\"/a/\",$s,$m); //两个a都会被匹配到 部分修饰符还可以用于表达式内部 (?i)用来启用不区分大小写的匹配，(?-i)停用，此时，他们的作用范围持续到对应的括号结束 三、分组捕获 ()在正则中有两种用途：分组和捕获 普通捕获 (pattern) 匹配pattern并捕获结果，自动设置组号 命名捕获 (?\\pattern) 或者 (?’name’pattern) 匹配pattern并捕获结果，设置name为组名，普通捕获的0，1，2，数字还会捕获到 普通捕获组的反向引用 \\1,\\2 ,(\\w)(\\d)\\2\\1,匹配a11a 命名捕获组的反向引用 \\k\\ 或者 \\k’name’ (?\\\\d)abc\\k\\ 匹配1abc1 非捕获型括号(?:exp),仅用于分组，不能用来提取文本，只能用来规定多选结构或者量词的作用对象 (1|one)(?:and|or)(2|two) 匹配之后，$1包含1或者one ,$2包含2或者two 固化分组(?&lt;) 让多个子组可以共用一个后向引用数字(?|)(?| 语法允许复制数字。 考虑下面的正则表达式匹配Sunday：(?:(Sat)ur|(Sun))day这里当后向引用 1 空时Sun 存储在后向引用 2 中. 当后向引用 2 不存在的时候 Sat 存储在后向引用 1中。 使用 (?|修改模式来修复这个问题：(?|(Sat)ur|(Sun))day使用这个模式， Sun和Sat都会被存储到后向引用1中。","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www/lyj1215.com/categories/正则表达式/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://www/lyj1215.com/tags/正则表达式/"}]},{"title":"深拷贝和浅拷贝","slug":"copy","date":"2017-09-08T10:12:41.000Z","updated":"2017-09-20T09:51:15.000Z","comments":true,"path":"2017/09/08/copy/","link":"","permalink":"http://www/lyj1215.com/2017/09/08/copy/","excerpt":"","text":"深拷贝：赋值时完全复制，完全的copy，对其中一个做出改变，不会影响另一个 浅拷贝：赋值时，引用赋值，相当于取了一个别名。对其中一个修改，会影响另一个。 PHP中， = 赋值时，普通对象是深拷贝，但对对象来说，是浅拷贝。也就是说，对象的赋值是引用赋值。（对象作为参数传递时，也是引用传递，无论函数定义时参数前面是否有&amp;符号） php4中，对象的 = 赋值是实现一份副本，这样存在很多问题，在不知不觉中我们可能会拷贝很多份副本。 php5中，对象的 = 赋值和传递都是引用。要想实现拷贝副本，php提供了clone函数实现。 clone完全copy了一份副本。但是clone时，我们可能不希望copy源对象的所有内容，那我们可以利用__clone来操作。 在clone（）中，我们可以进行一些操作。注意，这些操作，也就是clone函数是作用于拷贝的副本对象上的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364实现对象这种的深拷贝，有两种方法：例子1：重写clone函数&lt;?phpclass Test&#123; public $a=1;&#125; class TestOne&#123; public $b=1; public $obj; //包含了一个对象属性，clone时，它会是浅拷贝 public function __construct()&#123; $this-&gt;obj = new Test(); &#125; //方法一：重写clone函数 public function __clone()&#123; $this-&gt;obj = clone $this-&gt;obj; &#125;&#125; $m = new TestOne();$n = clone $m; $n-&gt;b = 2;echo $m-&gt;b;//输出原来的1echo PHP_EOL;//可以看到，普通属性实现了深拷贝，改变普通属性b，不会对源对象有影响 //由于改写了clone函数，现在对象属性也实现了真正的深拷贝，对新对象的改变，不会影响源对象$n-&gt;obj-&gt;a = 3;echo $m-&gt;obj-&gt;a;//输出1，不随新对象改变，还是保持了原来的属性 例子2：序列化和反序列化class Test&#123; public $a=1;&#125; class TestOne&#123; public $b=1; public $obj; //包含了一个对象属性，clone时，它会是浅拷贝 public function __construct()&#123; $this-&gt;obj = new Test(); &#125; &#125; $m = new TestOne();//方法二，序列化反序列化实现对象深拷贝$n = serialize($m);$n = unserialize($n); $n-&gt;b = 2;echo $m-&gt;b;//输出原来的1echo PHP_EOL;//可以看到，普通属性实现了深拷贝，改变普通属性b，不会对源对象有影响 $n-&gt;obj-&gt;a = 3;echo $m-&gt;obj-&gt;a;//输出1，不随新对象改变，还是保持了原来的属性,可以看到，序列化和反序列化可以实现对象的深拷贝 例子3：json_encode之后再json_decode,实现赋值","categories":[{"name":"设计模式","slug":"design-mode","permalink":"http://www/lyj1215.com/categories/design-mode/"}],"tags":[{"name":"设计模式","slug":"design-mode","permalink":"http://www/lyj1215.com/tags/design-mode/"}]},{"title":"laravel框架中常用PHP语法","slug":"laravel-3","date":"2017-09-08T01:51:06.000Z","updated":"2017-09-20T03:46:12.000Z","comments":true,"path":"2017/09/08/laravel-3/","link":"","permalink":"http://www/lyj1215.com/2017/09/08/laravel-3/","excerpt":"","text":"一、文件包含1.include与require 共同点：include与require关键字用于包含并运行指定文件。 不同点：两者作用几乎一样，只是处理失败的方式不同。require在出错时产生E_COMPILE_ERROR级别的错误，因此会导致脚本程序运行终止，而include则是会产生E_WARNING级别错误，只会发出警告，而脚本程序会继续运行。 查找路径的方式12345678910if(如果定义了路径，不管绝对路径还是相对路径)&#123; include_path会被忽略，按参数给出的路径寻找；&#125;else if(只有文件名，没有目录名)&#123; 则按照include_path指定的目录寻找；&#125;else if(include_path没有)&#123; 在调用脚本所在的目录和当前工作目录下寻找&#125;else&#123; Include 发出一条警告，require发生一个致命错误&#125; include查找路径的方式比较，推荐由高到低 通过当前路径查找，好处是迁移到别的项目时什么都不用改 使用include_path，即默认路径，迁移项目是需要改php.ini 绝对路径，迁移项目时需要改代码 相对路径，迁移项目时什么都不用改，但是为什么不推荐，是因为当被多人include时，会存在bug1).文件存储如下图所示，当a.php include b.php，c.php include a.php2).当单独访问a.php没有问题，但是访问c.php就会报错，找不到b.php 如果包含了一个定义了路径的文件，如include “../file.php”,无论是相对路径还是绝对路径，系统只会在相应的路径下寻找该文件，例如一个文件以“../”开头，则解析器会在当前目录的父目录下寻找该文件。当一个文件被包含时，包含文件则继承了被包含文件拥有的变量，从该处开始，被包含文件可用的任何变量在包含的文件中也都可用，同时在被包含文件中定义的函数，类或者常量都具有全局作用域。 2.类的自动加载3.laravel中的实现 注：以上内容参考《PHP手册》和《laravel框架关键技术解析》以及laravel源代码","categories":[{"name":"框架分析","slug":"框架分析","permalink":"http://www/lyj1215.com/categories/框架分析/"}],"tags":[{"name":"laravel","slug":"laravel","permalink":"http://www/lyj1215.com/tags/laravel/"}]},{"title":"UML类图关系总结","slug":"uml","date":"2017-09-07T14:18:11.000Z","updated":"2017-09-08T06:58:08.000Z","comments":true,"path":"2017/09/07/uml/","link":"","permalink":"http://www/lyj1215.com/2017/09/07/uml/","excerpt":"","text":"在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency) 一、泛化（Generalization）【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。【箭头指向】：带三角箭头的实线，箭头指向父类 二、实现（Realization）【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现.【箭头指向】：带三角箭头的虚线，箭头指向接口 三、关联（Association)【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。【代码体现】：成员变量【箭头及指向】：带普通箭头的实心线，指向被拥有者 上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。 下图为自身关联： 四、聚合（Aggregation）【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。【代码体现】：成员变量【箭头及指向】：带空心菱形的实心线，菱形指向整体 五、组合(Composition)【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。【代码体现】：成员变量【箭头及指向】：带实心菱形的实线，菱形指向整体 六、依赖(Dependency)【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.【代码表现】：局部变量、方法的参数或者对静态方法的调用【箭头及指向】：带箭头的虚线，指向被使用者 各种关系的强弱顺序： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 下面这张UML图，比较形象地展示了各种类图关系： 转自：http://blog.csdn.net/tianhai110/article/details/6339565","categories":[{"name":"设计模式","slug":"design-mode","permalink":"http://www/lyj1215.com/categories/design-mode/"}],"tags":[{"name":"设计模式","slug":"design-mode","permalink":"http://www/lyj1215.com/tags/design-mode/"},{"name":"UML","slug":"UML","permalink":"http://www/lyj1215.com/tags/UML/"}]},{"title":"SQL注入","slug":"sql-injection","date":"2017-09-07T14:01:39.000Z","updated":"2017-09-13T07:28:49.000Z","comments":true,"path":"2017/09/07/sql-injection/","link":"","permalink":"http://www/lyj1215.com/2017/09/07/sql-injection/","excerpt":"","text":"一、目的简介 让这些输入被认为是一个SQL查询，或者是查询的一部分,针对程序员编程的忽略通过SQL语句，实现无账号登录甚至篡改数据库。 二、SQL注入攻击的总体思路： 寻找到SQL注入的位置 判断服务器类型和后台数据库类型 针对不同的服务器和数据库特点进行SQL注入攻击 三、SQL注入攻击实例1234567免账号登录：sql = \"select * from user_table where username=' \"+userName+\" ' and password=' \"+password+\" '\";当用户输入的用户名为 ‘or 1=1 --sql = \"select * from user_table where username=‘’ or 1=1 -- ' and password=' \"+password+\" ‘\";由于1=1肯定会成功 ，--是注释后面的语句不用执行，因此不用账号密码就可以登录成功。当用户输入的用户名为 ' ;DROP DATABASE (DB Name) —'以上语句则会删除数据库 四、防范： 服务器配置防范 关闭注册全局变量，在PHP中提交的变量，包括post或者get提交的变量，都将自动注册为全局变量，能够直接访问，对服务器是不安全的，所以应该关闭 register_globals=off 打开magic_quotes_gpc 防止SQL注入。 默认是关闭的，如果打开后将自动把用户提交对SQL的查询进行转换，比如把’ 转为\\’ 等 错误信息控制 一般数据库会在没有连接到数据库或者在其他情况下会有提示错误，一般错误信息中会包含PHP脚本当前的路径信息或者查询的SQL语句信息，因此display_errors = off ，关闭错误信息后把错误日志打开 PHP方法： addslashes() 强行加\\ mysql_real_escape_string()会判断字符集，但是对PHP版本有要求 mysql_escape_string() 不考虑连接的当前字符集","categories":[{"name":"安全","slug":"安全","permalink":"http://www/lyj1215.com/categories/安全/"}],"tags":[{"name":"安全，SQL注入","slug":"安全，SQL注入","permalink":"http://www/lyj1215.com/tags/安全，SQL注入/"}]},{"title":"MySQL执行顺序","slug":"mysql","date":"2017-09-07T13:52:19.000Z","updated":"2017-09-20T09:50:32.000Z","comments":true,"path":"2017/09/07/mysql/","link":"","permalink":"http://www/lyj1215.com/2017/09/07/mysql/","excerpt":"","text":"FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1 ON: 对虚表VT1进行ON筛选，只有那些符合的行才会被记录在虚表VT2中。 JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。 WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合的记录才会被插入到虚拟表VT4中。 GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5. CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6. HAVING： 对虚拟表VT6应用having过滤，只有符合的记录才会被 插入到虚拟表VT7中。 SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。 DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9. ORDER BY: 将虚拟表VT9中的记录按照进行排序操作，产生虚拟表VT10. LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://www/lyj1215.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www/lyj1215.com/tags/MySQL/"}]},{"title":"常见查找算法","slug":"search","date":"2017-07-16T15:30:07.000Z","updated":"2017-07-16T15:30:07.000Z","comments":true,"path":"2017/07/16/search/","link":"","permalink":"http://www/lyj1215.com/2017/07/16/search/","excerpt":"","text":"查找定义：根据给定的某个值，在查找表中确定一个七关键字等于给定值得数据元素。 查找算法分类： 静态查找和动态查找 有序查找和无序查找 平均查找长度 查找算法分类： 1）静态查找和动态查找； 注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。 2）无序查找和有序查找。 无序查找：被查找数列有序无序均可； 有序查找：被查找数列必须为有序数列。 平均查找长度（Average Search Length，ASL）：需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。 对于含有n个数据元素的查找表，查找成功的平均查找长度为：ASL = Pi*Ci的和。 Pi：查找表中第i个数据元素的概率。 Ci：找到第i个数据元素时已经比较过的次数。 一、顺序查找思路：一个一个的查复杂度：o(n)代码：12345678910111213141516171819202122232425262728function seqSearch($arr,$k)&#123; for($i=0;$i&lt;count($arr);$i++)&#123; if($arr[$i] == $k)&#123; return $i; &#125; &#125; return false;&#125;$items=[1,3,5,7,9,11,13,15];var_dump(seqSearch($items, 4));var_dump(seqSearch($items, 5));示例2：// $array为数组，$k为要查找的值 function search2 ($array, $val )&#123; $array[]=$val; $n = count($array); $i = 0; while( $array[$i] != $val )&#123; $i++; &#125; return ($i == $n-1) ? false : $i;&#125;$items=[32,55,6,33,921,543,123,666];var_dump(search2($items, 4));var_dump(search2($items, 55)); 二、二分查找思路：也称为是折半查找，属于有序查找算法。需要设定三个值，low=0；high=count-1;mid=(low+high)/2,用给定值k先与mid的关键字比较，若相等则查找成功；若mid值比k值大，则去查找前半部分，high=mid-1;若mid值比K值小，则去查找后半部分，low=mid+1;循环比较，直到mid==k,循环条件：low&lt;=high说明：必须是有序的，如果不是有序的可以先排序一下复杂度：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；代码：1234567891011121314151617181920function binarySearch($arr,$k)&#123; $len = count($arr); $low = 0; $high = $len-1; while($low &lt;= $high) &#123; $mid = intval(($low + $high) / 2); if ($arr[$mid] == $k) &#123; return $mid; &#125; elseif ($arr[$mid] &gt; $k) &#123; $high = $mid-1; &#125; else &#123; $low = $mid+1; &#125; &#125; return false;&#125;$array = array(2,3,4,7,9,10,11,18,19,20,33);var_dump(binarySearch($array,7)); 三、插值查找思路：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。mid=low+(key-a[low])/(a[high]-a[low])*(high-low)说明：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。 复杂度：查找成功或者失败的时间复杂度均为O(log2(log2n))。代码：12345678910111213141516171819202122232425function binarySearch ($array, $val )&#123; $low=0; $high=count($array)-1; while( $low&lt;=$high )&#123; if($low==$high)&#123; $mid=$low; &#125;else&#123; $mid= $low +( ( $val -$array[$low] )/( $array[$high]-$array[$low] ) ) * ( $high - $low ) ; if($mid&lt;0)return false; &#125; if( $val&lt;$array[$mid] )&#123; $high=$high-1; &#125;else if( $val&gt;$array[$mid] )&#123; $low=$low+1; &#125;else&#123; return $mid; &#125; &#125; return false;&#125;$items=[1,3,5,7,9,11,13,15];var_dump(binarySearch($items, 4));var_dump(binarySearch($items, 5));","categories":[{"name":"数据结构与算法","slug":"algorithm","permalink":"http://www/lyj1215.com/categories/algorithm/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://www/lyj1215.com/tags/算法/"}]},{"title":"常用地址","slug":"used-address","date":"2017-03-17T05:16:04.000Z","updated":"2017-07-23T11:16:04.000Z","comments":true,"path":"2017/03/17/used-address/","link":"","permalink":"http://www/lyj1215.com/2017/03/17/used-address/","excerpt":"","text":"学习 编程书籍大全 https://github.com/justjavac/free-programming-books-zh_CN 编程书籍2 https://github.com/jobbole/awesome-programming-books 廖雪峰官方网站 https://www.liaoxuefeng.com/ 牛客网 https://www.nowcoder.com/ PHP之道 https://laravel-china.github.io/php-the-right-way/ 啊哈磊算法 http://ahalei.blog.51cto.com/ PHP手册 http://php.net/manual/zh/index.php 深入PHP内核 http://www.php-internals.com/book/ 实验楼 https://www.shiyanlou.com/ 工具 json校验 http://www.bejson.com/ 时间戳转换 http://tool.chinaz.com/Tools/unixtime.aspx 正则表达式在线验证 http://regex.zjmainstay.cn/ PHP模拟器 https://3v4l.org/BIsAB 在线流程图 https://www.processon.com/ 住房公积金 http://www.bjgjj.gov.cn/ 社保查询 http://www.bjrbj.gov.cn/csibiz/home/#","categories":[{"name":"其他","slug":"其他","permalink":"http://www/lyj1215.com/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://www/lyj1215.com/tags/其他/"}]},{"title":"单例模式","slug":"singleton","date":"2017-03-16T13:40:35.000Z","updated":"2017-03-16T15:30:07.000Z","comments":true,"path":"2017/03/16/singleton/","link":"","permalink":"http://www/lyj1215.com/2017/03/16/singleton/","excerpt":"","text":"一、概览 设计原则：无 常用场景：应用中有对象需要是全局的且唯一 使用概率：99.99999% 复杂度：低 变化点：无 选择关键点：一个对象在应用中出现多个实例是否会引起逻辑上或者是程序上的错误 逆鳞：在以为是单例的情况下，却产生了多个实例 相关设计模式： 原型模式：单例模式是只有一个实例，原型模式每拷贝一次都会创造一个新的实例。 二、定义：单例模式：单例模式保证一个类只有一个实例，同时这个类还必须提供一个访问该类的全局访问点。 三、UML类图 单例模式的三个要点： 需要一个保存类的唯一实例的静态成员变量 构造函数和克隆函数必须私有 必须提供一个访问这个实例的公共静态方法，从而返回唯一实例的一个引用 那么为什么要使用PHP单例模式？ PHP一个主要应用场合就是应用程序与数据库打交道的场景，在一个应用中会存在大量的数据库操作，针对数据库句柄连接数据库的行为，使用单例模式可以避免大量的new操作。因为每一次new操作都会消耗系统和内存的资源。 单例模式代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?php/** * class Singleton */class Singleton&#123; /** * @var Singleton reference to singleton instance */ private static $instance; /** * gets the instance via lazy initialization (created on first usage) * * @return self */ public static function getInstance() &#123; if (null === static::$instance) &#123; static::$instance = new static; //static 相当于self &#125; return static::$instance; &#125; /** * is not allowed to call from outside: private! * */ private function __construct() &#123; &#125; /** * prevent the instance from being cloned * * @return void */ private function __clone() &#123; &#125; /** * prevent from being unserialized * * @return void */ private function __wakeup() &#123; &#125;&#125; 单例模式优缺点：优点： 由于在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁的创建，销毁时 减少了系统的性能开销，读取配置，产生其他依赖对象时，可以通过在应用启动时直接产生一个单例对象。 可以避免对资源的多重占用，比如写文件动作，由于只有一个实例在内存中，可以避免对同一个资源文件的同时写操作 可以在系统设置全局的访问点，优化和共享资源访问，可以设计一个单例类，负责所有的数据表的映射处理缺点：1.一般没有接口，扩展困难，","categories":[{"name":"设计模式","slug":"design-mode","permalink":"http://www/lyj1215.com/categories/design-mode/"}],"tags":[{"name":"设计模式","slug":"design-mode","permalink":"http://www/lyj1215.com/tags/design-mode/"},{"name":"单例","slug":"单例","permalink":"http://www/lyj1215.com/tags/单例/"}]},{"title":"awk学习","slug":"awk","date":"2017-03-08T10:17:23.000Z","updated":"2017-03-08T10:17:23.000Z","comments":true,"path":"2017/03/08/awk/","link":"","permalink":"http://www/lyj1215.com/2017/03/08/awk/","excerpt":"","text":"awk是一个强大的文本分析工具，相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。使用方法：awk ‘{pattern + action}’ {filenames} 一、书写格式： 命令行格式 awk -F”:” ‘{print $2}’ test.txt 使用较多 文本格式#!/usr/bin/awkBEGIN {FS=”:”}{print $1} 以上为写好的文本格式file.awk执行.awk文件的命令为：awk -f file.awk test.txt 二、变量：常用内置变量 $0 全部内容 $1~$n 被分割的第n个字符 FS 分隔符（默认为空格） RS 输入记录的分隔符(默认为空格) NF 字段个数 NR 行号 自定义及外部变量 awk -v name=$myname ‘BEGIN{print name}’ $myname 是自己定义的变量 awk -v host=$HOSTNAME ‘BEGIN{print host}’ $HOSTNAME 是系统变量 awk -v name=‘lalalal’ ‘BEGIN{print name}’ 还可以直接定义 三、操作符 ~ 匹配匹配第7列中是以/bin开头的文件并输出╰─&gt;awk -F: ‘$7 ~ /^\\/bin/{print $0}’ /etc/passwd 17-08-16 11:04root::0:0:System Administrator:/var/root:/bin/sh_mbsetupuser::248:248:Setup User:/var/setup:/bin/bash !~ 不匹配匹配第7列中不是以/bin开头的文件并输出╰─&gt;awk -F: ‘$7 !~ /^\\/bin/{print $0}’ /etc/passwd 四、输出 print:直接打印 printf:格式化打印 五、流程控制 if seq 10 | awk ‘{if($0%2==0){print “ok”}else{print”no”}}’ while 给etc/passwd 中的每一个字段都加上序号╭─◆liuyajuan@liuyajuandeMacBook-Pro.local/Users/liuyajuan/Downloads╰─&gt;awk -F: ‘{i=1;while(i&lt;=NF){printf(“ %d:%s “,i,$i);i++}{print “ “ }}’ /etc/passwd for 六、BEGIN ,END 作用:给程序赋予初始化状态和在程序结束之后执行一些扫尾工作。任何在BEGIN之后列出的操作（在{}内）将在Unix awk开始扫描输入之前执行,而END之后列出的操作将在扫描完全部的输入之后执行因此，通常使用BEGIN来显示变量和预置（初始化）变量，使用END来输出最终结果。 七、练习题： 截取IP地址 12345678910111213┌─◆&lt;liuyajuan@liuyajuandeMacBook-Pro&gt; └─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; ifconfig en4en4: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 options=4&lt;VLAN_MTU&gt; ether 00:e0:4c:36:0b:9c inet6 fe80::140f:6090:e77a:14ca%en4 prefixlen 64 secured scopeid 0x4 inet 172.19.32.5 netmask 0xffffff00 broadcast 172.19.32.255 nd6 options=201&lt;PERFORMNUD,DAD&gt; media: autoselect (100baseTX &lt;full-duplex&gt;) status: active┌─◆&lt;liuyajuan@liuyajuandeMacBook-Pro&gt; └─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; ifconfig en4 | awk -F ' ' '/inet / &#123;print $2&#125;'172.19.32.5 2.统计网络连接数 1234567┌─◆&lt;liuyajuan@liuyajuandeMacBook-Pro&gt; └─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; netstat -an | awk '/^tcp/ &#123;++state[$NF]&#125; END &#123;for(key in state) print key,\"\\t\",state[key]&#125;' | column -tLISTEN 14SYN_SENT 2CLOSED 1TIME_WAIT 5ESTABLISHED 12","categories":[{"name":"Linux","slug":"Linux","permalink":"http://www/lyj1215.com/categories/Linux/"}],"tags":[{"name":"awk","slug":"awk","permalink":"http://www/lyj1215.com/tags/awk/"}]},{"title":"《程序员的数学思维修炼》整理","slug":"math","date":"2017-02-22T03:59:06.000Z","updated":"2017-09-22T05:57:16.000Z","comments":true,"path":"2017/02/22/math/","link":"","permalink":"http://www/lyj1215.com/2017/02/22/math/","excerpt":"","text":"最近上下班路上再看《程序员的数学思维修炼》，因此整理一下读书心得，仅供记录,整理可能需要较长时间，边读边整理 数据的表示 神奇的素数 递归-自己调用自己 排列组合-让数选边站队 余数-数据分组 概率-你运气好吗 翻一番是多少 数理逻辑-非此即彼 推理-逻辑的应用 几何图形构造 统筹规划 数据的表示","categories":[{"name":"其他","slug":"其他","permalink":"http://www/lyj1215.com/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://www/lyj1215.com/tags/其他/"}]},{"title":"git使用","slug":"git","date":"2017-01-05T04:00:33.000Z","updated":"2017-01-05T04:00:33.000Z","comments":true,"path":"2017/01/05/git/","link":"","permalink":"http://www/lyj1215.com/2017/01/05/git/","excerpt":"","text":"看完廖雪峰老师的git教程后，对git的使用有所了解，因此整理一下，作为参考 https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 一、Git简介1. Git的诞生2. 集中式vs分布式 集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。 那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 二、安装Git12以下是Mac下的安装└─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; brew install git 三、创建版本库 版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 12345678└─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; mkdir learnGit└─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; cd learnGit└─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; pwd/Users/liuyajuan/Sites/learnGit└─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; git init //利用git init 把这个目录变成Git可以管理的仓库，会发现当前目录下多了一个.git的目录//把文件添加到版本库的方法：└─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; git add test.txt //git add 添加文件└─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; git commit -m 'wrote a test file' // -m '' 是输入提交的说明，方便能从历史记忆里很快的找到需要的内容 初始化一个Git仓库，使用 git init 命令。 添加文件到Git仓库，分两步： 第一步，使用命令 git add ，注意，可反复多次使用，添加多个文件； 第二步，使用命令 git commit，完成。 四、时光机穿梭1. 版本回退 git status 查看哪些文件被修改，可以随时掌握工作区的状态 git diff 查看修改的内容 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令 git reset –hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 2. 工作区和暂存区 以上的learnGit就是我的工作区，工作区有一个隐藏的目录.git,这个就是Git的版本库版本库中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 3. 管理修改 Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 4.撤销修改 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 5.删除文件 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 五、远程仓库1. 添加远程库 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 2. 从远程库克隆 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 六、分支管理1. 创建与合并分支 查看分支：git branch 创建分支：git branch 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 2. 解决冲突 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 用git log –graph命令可以看到分支合并图。 3. 分支管理策略 Git分支十分强大，在团队开发中应该充分应用。 合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并 4. Bug分支 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 5. Feature分支 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。 6.多人协作 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 七、标签管理1. 创建标签 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； git tag -a -m “blablabla…” 可以指定标签信息； git tag -s -m “blablabla…”可以用PGP签名标签； 命令git tag可以查看所有标签。 2. 操作标签 命令git push origin 可以推送一个本地标签； 命令git push origin –tags 可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/ 可以删除一个远程标签 八、自定义git 忽略某些文件时，需要编写.gitignore;.gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！ └─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; git config –global alias.co checkout └─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; git config –global alias.ci commit └─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; git config –global alias.br branch └─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; git config –global alias.st status └─&gt;[娟姐 😜 👉 ]🤑 好好挣钱 🤑️ &gt;&gt; git config –global alias.last ‘log -1’","categories":[{"name":"其他","slug":"其他","permalink":"http://www/lyj1215.com/categories/其他/"}],"tags":[{"name":"git","slug":"git","permalink":"http://www/lyj1215.com/tags/git/"}]},{"title":"hexo相关配置以及遇到的问题","slug":"hexo2","date":"2016-12-11T11:20:33.000Z","updated":"2016-12-11T11:20:33.000Z","comments":true,"path":"2016/12/11/hexo2/","link":"","permalink":"http://www/lyj1215.com/2016/12/11/hexo2/","excerpt":"","text":"一、如何统计阅读量 对着配置看了半天都不知道该去如何设置文章的点击数,看如下的配置阅读量统计也是开启的，怎么不能页面不能显示呢，后来百度才发现是自己太天真了，原来leancloud是需要去注册才能使用的😂😂😂 12345678910## leancloud --- leancloud 阅读量统计## &#123;@leancloud:&#123;enable:是否开启,className:创建的class,app_id:,app_key:,region:默认为中国地区,limits:热门文章显示总数&#125;&#125;leancloud: enable: true className: \"baseCounter\" app_id: '' app_key: '' region: limits: 10 注册LeanCloud，这里不再赘述创建应用 创建阅读统计表 获取AppID和AppKey 更改配置 12345678910## leancloud --- leancloud 阅读量统计## &#123;@leancloud:&#123;enable:是否开启,className:创建的class,app_id:,app_key:,region:默认为中国地区,limits:热门文章显示总数&#125;&#125;leancloud: enable: true className: \"创建的名字\" app_id: '刚刚拷贝的app_id' app_key: '刚刚拷贝的app_key' region: limits: 10 二、如何在文章中插入图片其实这里就是markdown的语法了，无奈我不会，因此边学边用图片的语法和链接很像。 123456789101112131415 行内形式（title 是选择性的）：![alt text](/path/to/img.jpg \"Title\")参考形式：![alt text][id][id]: /path/to/img.jpg \"Title\"上面两种方法都会输出 HTML 为：&lt;img src=\"/path/to/img.jpg\" alt=\"alt text\" title=\"Title\" /&gt;","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://www/lyj1215.com/categories/环境搭建/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www/lyj1215.com/tags/hexo/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://www/lyj1215.com/tags/环境搭建/"}]},{"title":"hexo+github搭建免费网站","slug":"hexo","date":"2016-12-10T11:20:33.000Z","updated":"2016-12-10T11:20:33.000Z","comments":true,"path":"2016/12/10/hexo/","link":"","permalink":"http://www/lyj1215.com/2016/12/10/hexo/","excerpt":"","text":"一、准备工作 一个github账号 安装node.js(node官网下载)、npm(推荐brew安装) 安装git 二、在GitHub创建仓库 新建一个名为你的用户名.github.io的仓库 仓库名字必须是：username.github.io，其中username是你的用户名 三、安装hexo Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网：http://hexo.io github: https://github.com/hexojs/hexo 安装 npm install -g hexo 初始化 在电脑的某个地方新建一个名为blog的文件夹（名字可以随便取），我的是~/Sites/blog,进入目录执行 hexo init至此hexo安装完毕 四、本地运行 在项目根目录下执行 hexo s #启动服务 访问：http://localhost:4000 五、配置git 编辑 根目录下的 _config.yml 文件12345deploy: type: git repo: https://github.com/username/username.github.io #username就是你的用户名 branch: master message: 提交博客内容 安装插件 npm install hexo-deployer-git –save 提交 hexo d 如果提交失败需要清除 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 六、下载好看的主题和有用的插件 Plugins: https://hexo.io/plugins/ Themes: https://hexo.io/themes/ 主题里面自带使用教程这里就不多说了 七、绑定域名(依据个人情况) 如果不绑定域名肯定也是可以的，就用默认的 xxx.github.io 来访问 阿里云购买域名后 执行ping xxx.github.com得到对应的IP地址，去万网的控制台中解析购买的域名 在blog/source 目录下新建一个CNAME文件(无后缀名) 将自己的域名 www.lxzfranky.com填入其中,至此自己的博客基本已经完成 八、其他一些设置 详见根目录下的 _config.yml,另外会单独写一篇文章来讲解如何设置 九、开始你的博客之旅吧 到根目录下执行如下命令hexo会帮我们在_posts下生成相关md文件，打开这个文件编辑就好了 12345678910执行hexo new 'first'命令打开文件如下：---title: postName #文章页面上的显示名称，一般是中文date: 2017-07-07 19:39:39 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文 十、hexo一些常用命令 基本命令 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 缩写 hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 命令组合 hexo s -g #生成并本地预览 hexo d -g #生成并上传","categories":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://www/lyj1215.com/categories/环境搭建/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www/lyj1215.com/tags/hexo/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://www/lyj1215.com/tags/环境搭建/"}]},{"title":"第一篇博客诞生","slug":"first","date":"2016-11-06T10:42:37.000Z","updated":"2016-11-06T10:42:37.000Z","comments":true,"path":"2016/11/06/first/","link":"","permalink":"http://www/lyj1215.com/2016/11/06/first/","excerpt":"","text":"从此开启了博客之路，发布第一篇作为纪念！✌️","categories":[{"name":"杂文","slug":"other","permalink":"http://www/lyj1215.com/categories/other/"}],"tags":[{"name":"杂文","slug":"other","permalink":"http://www/lyj1215.com/tags/other/"}]}]}